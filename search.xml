<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Machine Learning 第三周]]></title>
    <url>%2F2017%2F11%2F10%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FAndrew%2FMachine%20Learning%20%E7%AC%AC%E4%B8%89%E5%91%A8%2F</url>
    <content type="text"><![CDATA[Week 3PROGRAMMINGLogistic RegressionVisualizing the data&emsp;&emsp;这一段可以自己写，但是在pdf中也有直接的代码可以添加在plotdata.m中：12345% Find Indices of Positive and Negative Examplespos = find(y==1); neg = find(y == 0);% Plot Examplesplot(X(pos, 1), X(pos, 2), 'k+','LineWidth', 2, 'MarkerSize', 7);plot(X(neg, 1), X(neg, 2), 'ko', 'MarkerFaceColor', 'y', 'MarkerSize', 7); Sigmoid Function&emsp;&emsp;根据公式可以直接求出。注意是点除，不是直接的相除。1g=1./(1+exp(-z)); Cost function and gradient&emsp;&emsp;根据公式，在costFunction.m中添加以下代码：12J=1/m*(-y'*log(sigmoid(X*theta))-(1-y)'*log(1-sigmoid(X*theta)));grad=1/m*((sigmoid(X*theta)-y)'*X); Evaluating logistic regression&emsp;&emsp;这个就是根据结果判断是0还是1了，在predict.m中添加以下代码：123h=sigmoid(X*theta);p(find(h&lt;0.5))=0;p(find(h&gt;=0.5))=1; Regularized logistic regressionCost function and gradient&emsp;&emsp;在原先的基础上添加一个正则项，matlab下标从1开始，这个问题让我找了半天的bug，在costFunctionReg.m中添加以下代码：123J=1/m*(-y'*log(sigmoid(X*theta))-(1-y)'*log(1-sigmoid(X*theta)))+lambda/2/m*(theta(2:end)'*theta(2:end));grad=1/m*((sigmoid(X*theta)-y)'*X);grad(2:end)=grad(2:end)+lambda/m*theta(2:end)';]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[考虑平局的投票分类器]]></title>
    <url>%2F2017%2F10%2F31%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在基础分类器中，除了最近邻的方法外，投票也是常用的一种方法。投票的原理是：每一个部分拥有一票或多票，根据一定的规则投给某一个类别，获得最多票数的类别是最终得到的类别。 基础算法&emsp;&emsp;很多matlab的实现投票分类器的代码如下：12345a=1:c; % c是类别数for i=1:num h(i,:)=hist(index(i,:),a); % index是一个矩阵,每一个位置都有一个数字，在0到c之间end[~,ind]=max(h,[],2); &emsp;&emsp;我一开始也是使用这种方法做的分类，但是老师问我，如果是2：2怎么办呢？在我的实验中，我已知的是一个距离矩阵，共有length(X_tst)行，length(X_trn) num列，即有多少个测试样本就有多少行，而训练样本数 分块数就是列数。在这种情况下，当分块数太小时很有可能出现平局的局面，而以上的算法并没有考虑到这个局面，它只是在平局时简单粗暴地选择了较小的序号。 考虑到平局的算法&emsp;&emsp;这个分类算法被我用于单样本人脸识别，因此代码可能不具有通用性，但是思想方法大体差别不大。 输入：距离矩阵D，共有length(X_tst)行，length(X_trn) * num列。前num列存放各个测试样本到训练图片1的num块的距离。输出：分类得到的结果ind流程： 对第$i$块，得到距离矩阵dt，表示测试样本到所有训练样本第$i$块的距离。从每个dt中得到一个最小距离向量和对应的索引向量。 将所有的距离向量连起来得到矩阵mindis，将所有的索引合起来得到矩阵index。 对每一块，用hist进行统计，并连起来。 求出每块中出现的最大次数times和对应的序号ind。 用sum和bsxfun函数一起判断有没有平局的出现。 对于出现平局的样本，找到平局中序号对应的最小距离，谁小测试样本就是那一类的。 &emsp;&emsp;比起使用for循环，matlab中更提倡矩阵的运算，所以一部分我是直接使用矩阵进行运算的。但是在处理平局时，我没有找到合适的函数。使用了两层for循环，对每一个测试样本，将距离排序，依次使用最小的距离，并判断最小的距离对应的序号是否在平局的序号中，如果不是再取第二小的，依次递推。 matlab代码123456789101112131415161718192021222324252627282930c=max(Y_trn); %类别数num=size(d,2)/c; %每个图像有多少块a=1:c;index=[];mindis=[];for i=1:num dt=[]; for j=1:c dt=[dt,d(:,num*(j-1)+i)]; end [dis,ind]=min(dt,[],2); mindis=[mindis,dis]; index=[index,ind];endfor i=1:length(Y_tst) h(i,:)=hist(index(i,:),a);end[times,ind]=max(h,[],2); % times出现的最大次数， ind：出现的最大次数对应的序号bf=bsxfun(@eq,h,times);s=sum(bf,2);% 最大次数出现了几次fd=find(s~=1); % 找到出现平局的情况[~, id]=sort(mindis,2);for i=1:length(fd) for j=1:num if bf(fd(i),index(fd(i),id(fd(i),j)))==1 ind(fd(i))=index(fd(i),id(fd(i),j)); break; end endend]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》之k近邻法]]></title>
    <url>%2F2017%2F10%2F22%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E4%B9%8Bk%E8%BF%91%E9%82%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;相似度查询有两种方法：&emsp;1. 范围查询，给定阈值。&emsp;2. k近邻查询，给定查询点和k。&emsp;&emsp;k近邻法是一种基本分类与回归的方法。其基本思想是：一个样本的k个最相近的样本大多属于某一个类，则该样本也属于这个类。因此，k近邻算法不具有显式的学习过程。k值的选择、距离度量和分类决策规则是k近邻方法的三个基本要素。 k近邻算法 k近邻算法流程输入：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中，$x \in X \subseteq R^n$为实例的特征向量，$y_i\in Y={c_1,c_2,…,c_K}$为实例的类别，$i=1,2,…,N$，实例特征向量$x$。输出：实例$x$所属的类$y$。(1) 根据给定的距离度量，在训练集$T$中找出与$x$最近的$k$个点，涵盖这$k$个点的$x$邻域记作$N_k(x)$。(2) 在$N_k(x)$中根据分类决策规则，决定$x$的类别$y$：$y=\arg \max \limits_{c_j}{\sum \limits_{x_i\in N_k(x)}I(y_i=c_j)}, i=1,2,…,N; j=1,2,…,K $其中$I$为指示函数，即当$y_i=c_j$时，$I$为1，否则为0。 &emsp;&emsp;k近邻的特殊情况是当$k=1$时，此算法被称为最近邻算法。 k近邻模型模型&emsp;&emsp;特征空间中，对于每个训练实例点$x_i$，距离该点比其他店更近的所有点组成的一个区域，叫做单元。k近邻算法就是利用训练数据集对特征向量空间进行划分。 距离度量&emsp;&emsp;距离度量公式定义为：$$L_p(x_i,x_j)=(\sum_{l=1}^{n}|x_i^{(l)}-x_i^{(l)}|^p)^\frac{1}{p}$$其中$p\geq 1$&emsp;&emsp;当$p=1$时，可以得到曼哈顿距离：$L_1(x_i,x_j)=\sum_{l=1}^{n}|x_i^{(l)}-x_i^{(l)}|$&emsp;&emsp;当$p=2$时，可以得到欧式距离：$L_2(x_i,x_j)=(\sum_{l=1}^{n}|x_i^{(l)}-x_i^{(l)}|^2)^\frac{1}{2}$ k值的选择&emsp;&emsp;k值的选择对算法有很大的影响。k值的减小意味着整体模型变得复杂，容易发生过拟合。如果选择较大的k值，可以减少学习的估计误差，但是学习的近似误差会增加。在应用中，k值一般取一个比较小的值。通常采用交叉验证法来选取最合适的k值。 分类决策规则&emsp;&emsp;k近邻法中的分类决策规则往往是多数表决，即由输入实例的k个近邻的训练实例中的多数类决定输入实例的类。这种决策规则等价于经验风险最小化。 k近邻法的实现：kd树&emsp;&emsp;我们在进行特征匹配是，通常采用两种方法：线性扫描和构建数据索引，而使用构建数据索引时，在无重叠时可采用kd树，重叠时可采用R树。&emsp;&emsp;kd树的全称是k-dimension tree，可以用于k近邻的寻找。 构造kd树&emsp;&emsp;kd树是一棵二叉树，也是一颗空间划分树（空间划分树：将整个空间划分为几个特定的部分，然后再特定的部分进行搜索）。 构造平衡kd树流程输入：$k$维空间数据集$T={x_1,x_2,…,x_N}$，其中$x_i=(x_i^{(1)},x_i^{(2)},…,x_i^{(k)})^T，i=1,2,…,N$输出：kd树算法流程：(1) 开始：构造根结点，根结点对应于包含$T$的$k$维空间的超矩形区域。&emsp;选择$x^{(1)}$为坐标轴，将$T$中所有实例的$x^{(1)}$的中位数（奇数个：取中间，偶数个：中间偏大）为切分点，将根结点对应的超矩形区域切分成两个子区域。左子结点对应于小于切分点的子区域，有子结点对应于大于切分点的子区域。落在切分超平面上的实例点保存在根节点。(2) 重复：对深度为$j$的切分点，选择$x^{(l)}$为切分的坐标轴，其中$l=j(modk)+1$（从1到$k$循环取），重复以上操作。(3) 直到两个子区域没有实例点存在时停止。从而形成kd树的区域划分。]]></content>
      <categories>
        <category>《统计学习方法》</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Extended local binary patterns for face recognition》阅读笔记]]></title>
    <url>%2F2017%2F10%2F18%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F%E3%80%8AExtended%20local%20binary%20patterns%20for%20face%20recognition%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Brief Introduction&emsp;&emsp;在原先的基础上提出了三种新的LBP算子。（后面具体的没有看） Proposed Method&emsp;&emsp; They propose a novel method based on PCA image reconstruction and LDA for face recognition. Our proposed methods effectively combine the advantages of PCA, LDA, and SVM. Framework Introduction&emsp;1.1 人脸识别现状（十分热门+提出很多算法+缺点（有挑战性））&emsp;1.2 人脸识别的关键问题（特征提取和分类器）+特征提取的重要性和挑战&emsp;1.3 全局特征和局部特征+优缺点&emsp;1.4 LBP的优点和缺点&emsp;1.5 本文算法和主要贡献 Related work Extended LBP descriptors&emsp;3.1 Angular-differences based descriptors&emsp;3.2 Radial-differences based descriptors&emsp;3.3 Statistical distribution examination of patterns Face representation Experiments Conclusions Other]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人脸识别</tag>
        <tag>论文阅读</tag>
        <tag>特征提取</tag>
        <tag>局部二值模式</tag>
        <tag>局部描述算子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《A two-phase face recognition method in frequency domain》阅读笔记]]></title>
    <url>%2F2017%2F10%2F18%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F%E3%80%8AA%20two-phase%20face%20recognition%20method%20in%20frequency%20domain%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Brief Introduction&emsp;&emsp;对图像进行DCT和DFT特征提取+（第一项）先求得k个近邻+将图像分成K个图片的融合，并求得每张图片对应的系数+计算测试样本和每类之间的距离 Proposed Method&emsp;&emsp; They proposed a two-phase representation method that uses DCT coefficients or DFT amplitude spectra for face recognition. It is more efficient than the naïve 1 norm-based sparse representation method. Framework Introduction&emsp;1.1 人脸识别价值+基于变换域的方法&emsp;1.2 基于DCT和DFT的算法的发展和分类+基于变换域的方法的优点&emsp;&emsp;1.2.1 使用一部分DCT系数和DFT幅度谱&emsp;&emsp;1.2.2 使用全部DCT系数和DFT幅度谱&emsp;1.3 新的二相分类方法算法+优点&emsp;1.4 本文算法流程&emsp;1.5 文章组织结构 The Proposed algorithm Experimental results&emsp;3.1 Performance comparison&emsp;3.2 Number of DCT coefficients and DFT amplitude spectra Conclusions Other 离散余弦变换：discrete cosine transform 离散傅立叶变换：discrete Fourier transform 幅度谱：amplitude spectra 变换域：transform domain 整体的：holistic 误差：deviation]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人脸识别</tag>
        <tag>论文阅读</tag>
        <tag>离散余弦变换</tag>
        <tag>离散傅立叶变换</tag>
        <tag>无监督学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Face recognition based on PCA image reconstruction and LDA》阅读笔记]]></title>
    <url>%2F2017%2F10%2F17%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F%E3%80%8AFace%20recognition%20based%20on%20PCA%20image%20reconstruction%20and%20LDA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Brief Introduction&emsp;&emsp;预处理（直方图均衡化+PCA图像重建（新）+LDA+SVM Proposed Method&emsp;&emsp; They propose a novel method based on PCA image reconstruction and LDA for face recognition. Our proposed methods effectively combine the advantages of PCA, LDA, and SVM. Framework Introduction&emsp;1.1 人脸识别现状（概念+价值+十分热门+有挑战性）&emsp;1.2 人脸识别的关键问题（特征提取和分类器）&emsp;&emsp;1.2.1 PCA（由来+发展）&emsp;&emsp;1.2.2 LDA（影响+思想+缺点+发展）&emsp;1.3 本文算法流程+优点 Related algorithms&emsp;2.1 Principal component analysis(PCA)&emsp;2.2 Linear Discriminant Analysis(LDA)&emsp;2.3 Support vector machine (SVM) Face recognition based on PCA image reconstruction and LDA&emsp;3.1 Image preprocessing(histogram equalization)&emsp;3.2 PCA image reconstruction&emsp;3.3 PCA image reconstruction and LDA for face recognition（算法流程） Experimental results and discussion&emsp;4.1 Experiments on ORL database&emsp;4.2 Discussion Conclusions Sentences Face recognition is a technology of using computer to analyze the face images and extract the features for recognizing the identity of the target. The research of face recognition has great theoretical value, involving subjects of pattern recognition, image processing, computer vision, machine learning, physiology, and so on, and it also has a high correlation with other biometrics recognition methods. In recent years, face recognition is one of the most active and challenging problems in the field of pattern recognition and artificial intelligence. Other 直方图均衡化：histogram equalization]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人脸识别</tag>
        <tag>论文阅读</tag>
        <tag>无监督学习</tag>
        <tag>独立成分分析</tag>
        <tag>主成分分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《LBP 和 HOG 的分层特征融合的人脸识别》阅读笔记]]></title>
    <url>%2F2017%2F10%2F17%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F%E3%80%8ALBP%20%E5%92%8C%20HOG%20%E7%9A%84%E5%88%86%E5%B1%82%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;使用LBP和HOG两种局部特征，并采用分层的思想，将纹理特征和边界特征融合。 内容&emsp;&emsp;万源和李欢欢等提出了将LBP 算子和 HOG 算子进行融合, 利用分层的思想，实现局部和整体特征融合的人脸识别方法。对人脸图像进行分块提取LBP 和 HOG 特征能够反映人脸的局部特征, 进而考虑整体的 LBP 和 HOG 特征又能反映人脸的整体特征, 最终实现全局和局部特征的融合. 组织架构 背景介绍&emsp;1.1 人脸识别方法分类。&emsp;1.2 对本文中使用的第二种算法的现状（后人的改进）进行详细介绍。&emsp;1.3 提出新的算法。 算法描述&emsp;2.1 LBP 特征&emsp;2.2 HOG 特征&emsp;2.3 本文特征融合方法&emsp;&emsp;2.3.1 分层特征（多提取几次）&emsp;&emsp;2.3.2 分层 LBP 与原始 HOG 特征的融合步骤&emsp;&emsp;2.3.3 分层 LBP 与基于分层 LBP 的分层 HOG 特征的融合步骤&emsp;&emsp;2.3.4 相似性度量方法 仿真实验与实验分析&emsp;3.1 实验环境及预处理&emsp;3.2 特征融合算法比较（介绍对比方法）&emsp;3.3 ORL 人脸库实验结果分析&emsp;&emsp;3.3.1 分块大小的比较&emsp;&emsp;3.3.2 相似性度量方法比较&emsp;&emsp;3.3.3 融合方法效果图&emsp;3.4 Yale 人脸库实验结果分析&emsp;&emsp;3.4.1 分块大小的比较&emsp;&emsp;3.4.2 相似性度量方法比较&emsp;&emsp;3.4.3 融合方法效果图&emsp;3.5 Yale 人脸库实验结果分析&emsp;&emsp;3.5.1 分块大小的比较&emsp;&emsp;3.5.2 相似性度量方法比较&emsp;&emsp;3.5.3 融合方法效果图&emsp;3.6 时间复杂度分析&emsp;3.7 算法性能评价（排序值评测法） 结论 参考 人脸识别常用的方法主要有 2 种：&emsp;(1)基于全局特征的人脸识别技术, 其核心思想是将高维的人脸图像特征通过线性或非线性变化映射到一个低维的子空间中, 使得原始样本特征在这个低维子空间中更易于分类。全局特征能够有效地表示人脸的整体轮廓, 经典的方法是主成分分析(principle component analysis, PCA)、线性判别分析(linear discriminant analysis, LDA)、独立成分分析(independent component analysis, ICA)等.&emsp;(2)一种是基于局部特征的人脸识别技术, 局部特征侧重于反映人脸的细节特征, 其中广泛使用的有局部二值模式(local binary pattern, LBP)、尺度不变特征变换 (scale invariant feature transform,SIFT)以及梯度方向直方图(histogram of orientedgradient, HOG)等. LBP 特征主要提取图像的纹理信息, HOG 特征可以提取图像完整的边缘和形状信息, 并利用纹理信息和边缘轮廓信息的互补性提高识别率, 且将局部特征和整体特征相结合, 进一步将分层信息融合进行人脸识别。 其他 分类器中使用的距离被称为：相似性度量方法。]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人脸识别</tag>
        <tag>论文阅读</tag>
        <tag>特征提取</tag>
        <tag>局部二值模式</tag>
        <tag>梯度方向直方图</tag>
        <tag>分层特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Face recognition based on PCA and logistic regression analysis》阅读笔记]]></title>
    <url>%2F2017%2F10%2F17%2F%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%2F%E3%80%8AFace%20recognition%20based%20on%20PCA%20and%20logistic%20regression%20analysis%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Brief Introduction&emsp;&emsp;使用PCA进行特征提取，使用LRC作为分类器。 Proposed Method&emsp;&emsp;ChangjunZhou proposed a novel face recognition method which is based on PCA and logistic regression.By combining the advantages of both the PCA and logistic regression, they use PCA to extract feature and reduce the dimensions of process data and use logistic regression as the classifier for face recognition. Framework1 Introduction&emsp;1.1 人脸识别现状（十分热门，但是有挑战性+影响因素，提出了很多方法）&emsp;1.2 文章解决的两类问题&emsp;&emsp;1.2.1 特征提取（PCA由来+简介）&emsp;&emsp;1.2.2 分类器（分类器简介+SVM优点缺点+LRC算法简介和进化）&emsp;1.3 本文算法优点&emsp;1.4 文章组织结构2 Related algorithms&emsp;2.1 Principal component analysis(PCA)&emsp;2.2 Logistic regression analysis3 Proposed face recognition method（算法的流程）4 Experimental results and discussion&emsp;4.1 Yale database&emsp;4.2 ORL database5 Conclusions Sentences Face recognition is an important research hotspot in the fields of pattern recognition and artificial intelligence, and it has attained great success in recent years. Assume we have a training set …… with N images,belonging to c classes. First, we preprocessed the input images, mainly including histogram equalization, geometry normalization, in order to remove the illuminations, shades, and lighting effects possibly, and then partitioned into a training set from face database and the rest is a testing set. To illustrate the efficacy of our proposed method, we compared the performances on two standard databases, i.e., Yale database and the ORL database. The Yale face database contains images with major variations, including changes in illumination conditions, subjects wearing eyeglasses and different facial expressions. This database involves 165 frontal facial images, with 11 images of 15 individuals. To evaluate the effectiveness of the algorithms better, each image is scaled down to the size of 100 × 100 pixels. Other 类间离散矩阵：between-class scatter matrix 类内离散矩阵：within-class scatter matrix]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>人脸识别</tag>
        <tag>论文阅读</tag>
        <tag>PCA</tag>
        <tag>逻辑回归</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning 第一周和第二周]]></title>
    <url>%2F2017%2F10%2F16%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FAndrew%2FMachine%20Learning%20%E7%AC%AC%E4%B8%80%E5%91%A8%E5%92%8C%E7%AC%AC%E4%BA%8C%E5%91%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一直有想看Andrew Ng的机器学习课程，但是拖了很久都没有看完。之前也写过一些相关的博客，但是在博客搬家的时候没有保存下来。&emsp;&emsp;第一周和第二周的内容比较少，作业也是在一起布置的。 WEEK 1IntroductionWhat is machine learning? 机器学习的定义：为了完成某个目标T，从经验E中学习，同时具有一定的判断标准P。 Supervised Learning 监督学习：部分样本已有正确的结果。 分类：&emsp;回归问题（regression）：预测输出结果是连续值。&emsp;分类问题（classification）：预测输出结果是离散值。 Unsupervised Learning 从数据本身的结构中得到模型。 预测结果无反馈。 Linear Regression with One Variable（单变量线性回归）Model Representation 符号定义：&emsp;$m$：训练样本数&emsp;$x’s$：输入变量&emsp;$y$：输出变量&emsp;$(x,y)$：一个训练样本&emsp;$(x^{(i)},y^{(i)})$：第$i$个训练样本 Cost Function 假设函数：$h_\theta(x)=\theta_0+\theta_1x$ 代价函数（误差平方函数）：$J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)^2$ 目标：最小化代价函数&emsp; $minmize J(\theta_0,\theta_1)$ Cost Function-Intuition 1Cost Function-Intuition 2 $h_\theta(x)$是关于$x$的函数，$J(\theta_0,\theta_1)$是关于$\theta_0,\theta_1$的函数。 可以通过轮廓图来判断$\theta_0,\theta_1$和$J(\theta_0,\theta_1)$的关系。 Gradient Descent（梯度下降） 思想：&emsp;(1). 选取一组$\theta_0,\theta_1$（通常都为0）&emsp;(2). 不断更新$\theta_0$和$\theta_1$，直到$J(\theta_0,\theta_1)$达到局部最小值。 repeat until covergence{&emsp;&emsp;$\theta_j:=\theta_j-\alpha\frac{d}{d\theta_j}J(\theta_0,\theta_1)$} &emsp;其中$\alpha$是学习速率 在变量更新过程中应保持同步更新。 Gradient Descent Intuition $\alpha$（学习速率）：&emsp;(1). 过大，可能无法达到局部最低点。&emsp;(2). 过小，十分缓慢地达到局部最低点。 通常，越靠近最低点，曲线的斜率越靠近0，迈的步子越小，所以没有必要在过程中修改$_alpha$。 Gradient Descent For Linear Regression 对变量的改变的求导展开为&emsp;$\theta_0:=\theta_0-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)$&emsp;$\theta_1:=\theta_1-\alpha\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)\cdot x_i$ Linear Algebra ReviewMatrices and Vextors 一般使用大写字母表示矩阵，小写字母表示向量。 $R$表示实数集，$R^n$表示由实数集组成的$n$维向量。 Addition and Scalar Multiplication Scalar Multiplication：标量乘法，即一个实数乘以一个矩阵。 Matrix Vector Multiplication 一个$m\times n$的矩阵与一个$n\times 1$的向量相乘的结果是一个$m\times 1$的向量。 Matrix Matrix Multiplication 一个$m\times n$的矩阵与一个$n\times o$的矩阵相乘的结果是一个$m\times o$的矩阵。 Matrix Multiplication Properties（矩阵乘法的特性）Inverse and Transpose $A$的逆矩阵为$A^{-1}$。 一个非方阵的矩阵无逆矩阵。 WEEK 2Multivariate Linear Regression（多元线性回归）Multiple Features 符号定义：&emsp;$n$：特征的数量&emsp;$x^{(i)}$：第$i$个样本的特征&emsp;$x_{j}^{(i)}$：第$i$个样本的第$j$个特征 Gradient Descent for Multiple Variables 假设：$h_\theta(x)=\theta^Tx=\theta_0x_0+\theta_1x_1+…+\theta_nx_n$，其中$x_0=1$。 变量：$\theta=[\theta_0,\theta_1,…,\theta_n]^T$ 代价函数：$J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)^2$ 更新： repeat until covergence{&emsp;&emsp;$\theta_j:=\theta_j-\alpha\frac{1}{m}h_{theta}(x_i)-y_i)x_{j}^{(i)}$} Gradient Descent in Practice 1-Feature Scaling（特征缩放） 特征的尺度相似时，梯度下降进行得更快。 均一化（Mean normalization）：$x_i=\frac{x_i-\mu_i}{s_i}$，其中$\mu_i$是均值，$s_i$是范围（最大值-最小值） Gradient Descent in Practice 2-Learning rate 可以通过画$J(\theta)$和迭代次数的关系曲线图，来判断$\alpha$的选择是否正确。 正常情况下，$J(\theta)$会随着迭代次数的增加而减小。 $J(\theta)$下降得很慢，则$\alpha$过小。 $J(\theta)$上升或者不是持续下降，则$\alpha$过大。 Features and Polynomial Regression 改进假设函数的方法：&emsp;(1). 将多个特征合为一个特征。&emsp;(2). 多项式回归。 Computing Parameters AnalyticallyNormal Equation（正规方程） 正规方程求解$\theta$时可以一步到位。 假设有$m$个变量，每个变量有$n$个特征。构建$X=\begin{bmatrix}1 &amp; 1 &amp; … &amp; 1 \\x^{(1)} &amp; x^{(1)} &amp; … &amp; x^{(m)}\end{bmatrix} ^T$，$Y=[y^{(1)},y^{(2)},…,y^{(m)}]^T$$X\theta = Y$所以$\theta =(X^TX)^{-1}X^TY$ 对正规方程来说，没有必要使用特征缩放。 正规方程：$\theta \in R^{n+1}$，即求得$\theta _0,\theta _1, …,\theta _n$使得$\frac{d}{d\theta _j}J(\theta )=…=0$，其中$J(\theta_0,\theta_1)=\frac{1}{m}\sum_{i=1}^{m}(h_{\theta}(x_i)-y_i)^2$。 对比：|梯度下降|正规方程||:–:|:–:||需要选择$\alpha$|不需要选择$\alpha$||需要迭代|不需要迭代||时间复杂度$O(n^2)$|时间复杂度$O(n^3)$||$n$大时也有效|当$n$大时，运行缓慢| $n\leq 10000$，可选择正规方程求解。 Normal Equation Noninvertibility（不可逆性） $X^TX$不可逆的原因可能为：&emsp;(1). 特征之间关联大。&emsp;(2). 特征数量太多。 PROGRAMMINGwarmUpExercise&emsp;&emsp;在warmUpExercise.m中添加：1A = eye(5); Linear regression with one variablecomputeCost&emsp;&emsp;在computeCost.m中添加：12ypre=X*theta;J=1/2/m*sum((ypre-y).^2); gradientDescent&emsp;&emsp;gradientDescent.m中添加：1theta=theta-(alpha/m*sum(bsxfun(@times,X*theta-y,X)))'; Linear regression with multiple variablesFeature Normalization&emsp;&emsp;在featureNormalize.m中添加：123mu=mean(X);sigma=std(X);X_norm=bsxfun(@rdivide,bsxfun(@minus,X,mu),sigma); computeCostMulti&emsp;&emsp;在computeCostMulti.m中添加：12ypre=X*theta;J=1/2/m*sum((ypre-y).^2); gradientDescentMulti&emsp;&emsp;在gradientDescentMulti.m中添加：1theta=theta-(alpha/m*sum(bsxfun(@times,X*theta-y,X)))'; &emsp;&emsp;在ex1_multi.m中修改：12price = [1650,3];price=[1,(price-mu)./sigma] * theta; normalEqn&emsp;&emsp;normalEqn.m中添加：1theta=X'*X \ X'*y; &emsp;&emsp;在ex1_multi.m中修改：12price = [1,1650,3];price=price* theta;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从苏大到东南，四年又三年]]></title>
    <url>%2F2017%2F10%2F10%2F%E9%9A%8F%E8%AE%B0%2F%E4%BB%8E%E8%8B%8F%E5%A4%A7%E5%88%B0%E4%B8%9C%E5%8D%97%EF%BC%8C%E5%9B%9B%E5%B9%B4%E5%8F%88%E4%B8%89%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;保研的所有在9月28日定下来了，最后去了东南大学计算机科学与工程学院，进了PALM实验室，以后可能会做自然语言处理。 前期准备&emsp;&emsp;在我高考炸了报考苏大的时候，就准备读研了。当时还想着读了其他专业转专业到金融来着，但是读了一年计算机觉得也可以，比金融好一些，就放弃了转专业。但是从始至终我都知道自己是要读研究生的，所以也不存在晃晃荡荡的。绩点也还可以，保证我可以拿到校内的保研名额，也没有挂过科。&emsp;&emsp;科研方面，很多人加入了ACM，然后去打比赛，拿铜牌银牌金牌，我认识一个保研去了南大现在在微软实习的大佬就是拿了金牌，当然他本身就很厉害。我是在大一的时候，在一个老师的介绍下加入了机器学习课题组，做单样本人脸识别相关的实验，然后写了一篇很简单的英文论文。但是在高校夏令营开始的时候论文还没录用，所以很多夏令营我都不敢去。&emsp;&emsp;保研是一个长期工作，大概前期就是保持成绩好，然后做一些项目来充实自己，让简历有东西可填，自我介绍的时候有话可以说。 PALM实验室面试&emsp;&emsp;在一个学长的介绍下知道了PALM实验室，听说很厉害的样子，耿新老师很有名，虽然在网上并不能查到什么资料。6月末，有个原先是苏大后来去了东南的师兄在隔壁班的群里发了PALM的面试招生的要求，潘大佬顺带发给了我，然后我们就兴冲冲地报了名。&emsp;&emsp;报名就是给薛晖老师发了一封邮件，附件是自己的简历。最好提前就准备一份好看的简历，可以参考下网上的一些要求。多检查几次，我就是第一次发错了，然后又重发的。邮件正文最好也是写一些东西，以表现出自己的真诚和期待。&emsp;&emsp;在发了简历之后几天，就收到了实验室的面试通知，基本上身边的发了都收到了，然后大家就组团去面试。面试要求准备一份PPT和对应的自我介绍。经验就是，PPT保持16：9就好，然后放在U盘的根目录下，以自己的姓名保存。&emsp;&emsp;面试的教室就像一般的会议室，老师坐在对面，学生坐在另一边，用电脑进行幻灯片的放映和介绍。老师会根据你的PPT来对你进行提问，并不是很严肃的，就是像聊天一样。当时我还太紧张，有些没有听清。大概十分钟左右就结束了。出来和他们聊天，发现如果老师对你有兴趣，就会多问一些问题。所以有什么特长啊，不要藏着掖着，在自我介绍的时候要说出来。&emsp;&emsp;面试的当晚11点左右，就收到了实验室通过的邮件，并给我分了老师。然后就是和分配的老师邮件交流之类的。这个是后话了。&emsp;&emsp;另外在东南预招生结束后一般PALM实验室也会有一次招生，不过那次竞争就比较激烈了。当然，对大佬不存在问题。 东南预招生&emsp;&emsp;东南预招生报名时间比较长，去考试的时后也比较晚了，在8月28日-8月29日。预招生的报考专业在之后可以修改，所以在联系老师之后发现老师与报考方向不同也没有问题，在录取后会有一次更改的机会。我当时报了计科，然而最后还是滚去了软件工程。&emsp;&emsp;笔试考的是操作系统和数据结构两门。考试时间好像是100分钟，大概有十道题左右。操作系统比较简单，数据结构比较难。操作系统考到了了甘特图，数据结构考了平衡树的插入与删除、数据的保存、算法的实现（在O(n)的时间复杂度中实现判断链表保存的字符串是不是回文），其余的我不记得了。我大概复习了一个月的数据结构和操作系统，操作系统是将考研的书看了一遍，数据结构是借的学校的一本书，看完还是很有收获的。&emsp;&emsp;笔试玩就是导师介绍，然而并没有，只有一个教务处老师来和我们说了一些注意事项。&emsp;&emsp;面试分组我被分到了第一个，这导致了我前一天晚上完全没有睡好。当然可能我是第一个，我面试的时候老师也没准备好，就让我做了一下中文的自我介绍，以及问了我报考了哪些学校就让我出去了。一脸懵逼。不是说好的会考英文的么？准备了一个晚上的英文和项目介绍，3分钟我就结束了我的面试。当然在事后听说有全英文面试的，室友也是被怼的体无完肤，但是凭借良好的认错态度也过了。提问的问题基本和报考的方向有关，可以事先准备一下。&emsp;&emsp;在9月3日左右出了结果，可以在官网看到。 苏大保研名额&emsp;&emsp;我原来以为苏大保研名额很好拿的，所以浪到6号才回的学校。然而一回学校就通知我9月14日就要考试。我又开始手忙脚乱地准备学校的保研考试。软件工程大概就是4-5个名额的样子，说好的10%都是骗人的。考试分为上机和面试两个部分。上机总分100分，选择50分，编程50分，最后再把总分乘以1.2，所以是120分。面试80分。上机的准备就是把往年的题目做一遍，我是每天三题做，选择就是一份一份地刷。如果开始的早的话，可以先把C语言书看一遍。&emsp;&emsp;苏大编程基本三个类型：一是超简单的C语言考试的水平，二是字典树这种和字符串有关的，三是和坐标、点有关的。和出试卷的老师有关。刷一遍往年的就差不多了。&emsp;&emsp;面试基本靠运气抽题，抽到好就简单。然而我们那组的面试老师有院长，基本都是被怼的体无完肤。这个，主要还是看平时和老师的关系吧。 其余一些话&emsp;&emsp;厉害的大佬们都去了清华北大中科院浙大啊等等等等，有兴趣的可以都去试试，反正除了车费和住宿也不花啥钱，万一中了还有个好大学。我就是太怂不敢去。其实去的多的同学说，问的问题都是差不多的，之前回答不出来，回来准备下，下次就能答出来了。&emsp;&emsp;关于南大，南大今年我们学校的专业第一也不要，只要大佬。绝望.jpg。&emsp;&emsp;祝看到的各位前程似锦。（虽然我觉得我的并不能被检索到）]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》之感知机]]></title>
    <url>%2F2017%2F09%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2F%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%8B%E4%B9%8B%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;感知机（perceptron）是一种二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，通常取$+1$和$-1$两值。感知机学习目的是求出将训练数据进行线性划分的分离超平面。 感知机模型超平面&emsp;&emsp;对于超平面，我们常用以下的方程来表示：$$\omega\cdot x+b=0$$其中，$\omega$是超平面的法向量，这决定超平面的方向，$b$是超平面的截距，决定超平面到原点的距离。&emsp;&emsp;一般来说，超平面维度都大于3。百度百科上解释超平面是$n$维空间到$n-1$维空间的映射，因为超平面的自由度比空间维数小1，其中自由度大体是指给多少分量值才可以确定位置。&emsp;&emsp;超平面将一个空间划分成两部分，位于两部分的点分别被分成正、负两类，这也恰好说明了感知机是一种二类分类的线性分类器。 模型&emsp;&emsp;假设特征空间是$X\subseteq {R}^{n}$，输出空间是$Y={+1,-1}$。则感知机模型是由输入空间到输出控件的如下函数：$$f(x)=sign(\omega \cdot x + b) $$其中，$\omega \in {R}^{n}$被称为权值或权值向量，$b \in {R}^{n}$被称为偏置。$\omega \cdot x$为$\omega$和$x$的内积，$sign$是符号函数，两者的具体计算公式如下：$$\omega \cdot x= \omega_1x_1+\omega_2x_2+…+\omega_nx_n$$$$sign(x)=\left\{\begin{matrix}+1 &amp; x\geq 0 &amp; 超平面上或正面 \\-1 &amp; x &lt; 0 &amp; 超平面的背面\end{matrix}\right.$$ 感知机学习策略数据集的线性可分性&emsp;&emsp;假设给定一个数据集，如果存在某个超平面能将数据集中的正实例点和负实例点正确地划分到数据集的两侧，则称这个数据集是线性可分数据集，否则称这个数据集线性不可分。 感知机学习策略&emsp;&emsp;之前提过，策略是评判一个模型的标准。感知机的学习目标是求得一个能够正确分离数据点的分离超平面。而为了找到这样的一个超平面，即确定超平面的参数$omega$和$b$，我们需要确定一个学习策略。&emsp;&emsp;输入空间中的任何一个点$x_0$到超平面的距离为：$$\frac{1}{\begin{Vmatrix}\omega\end{Vmatrix}}\begin{vmatrix}\omega \cdot {x}_{0} +b\end{vmatrix}$$&emsp;&emsp;而对于误分类点来说，$$-y_i(\omega \cdot x_i +b)&gt;0$$&emsp;&emsp;所以我们可以将误分类点到超平面的距离统一写成如下形式：$$-\frac{1}{\begin{Vmatrix}\omega\end{Vmatrix}} y_i(\omega \cdot x_i +b)$$&emsp;&emsp;所以，假设超平面的误分类点集合为$M$，所有误分类点到超平面的距离总和为：$$-\frac{1}{\begin{Vmatrix}\omega\end{Vmatrix}}\sum_{x_i \in M}^{} y_i(\omega \cdot x_i +b)$$不考虑$\frac{1}{\begin{Vmatrix}\omega\end{Vmatrix}}$，就可以得到感知机的损失函数为：$$L(\omega ,b)=-\sum_{x_i \in M}^{} y_i(\omega \cdot x_i +b)$$&emsp;&emsp;显然，损失函数$L(\omega ,b)$是非负的。如果没有误分类点，则损失函数的值为0.误分类点个数越少，误分类点离超平面越近，损失函数值就越小。一个特定样本点的损失函数：在误分类时是参数$\omega$、$b$的线性函数，在正确分类时是0.因此，对于给定的训练数据集$T$，损失函数$L(\omega ,b)$是$\omega$、$b$的连续可导函数。 感知机学习算法感知机学习算法的原始形式&emsp;&emsp;感知机学习算法是误分类驱动的，要想最小化感知机的损失函数，可以采用随机梯度下降算法。梯度下降算法在coursera上的Machine Learning课程的一开始有很详细的讲解。 感知机学习算法的原始形式输入：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中$x_i \in X=R^n$，$y_i \in Y={-1, +1}$，$i=1,2,…，N$，学习率$\eta (0 &lt; \eta \leq 1)$;输出：$\omega ,b$；感知机模型$f(x)=sign(\omega \cdot x + b)$(1) 选取初始值$\omega _0, b_0$(2) 在训练集中选取数据$(x_i, y_i)$ （2、3两步是根据误分类点调整参数，一般我们选点还是按照1至N的顺序选）(3) 如果$y_i(\omega \cdot x_i +b)\leq 0$$$\omega \leftarrow \omega +\eta y_ix_i$$$$b\leftarrow b +\eta y_i$$(4) 转至(2)，直至训练集中没有误分类点 &emsp;&emsp;这个算法直观上有如下解释：当一个实例点被误分类，就调整参数值，让超平面向该误分类点移动，以减少两者之间的距离，直到超平面将该误分类点正确分类。 算法的收敛性&emsp;&emsp;用变量$\hat{\omega }$ 表示$(\omega ^T, b)^T$。这里存在两个定理（Novikoff）：&emsp;&emsp;假设训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$是线性可分的，其中$x_i \in X=R^n$，$y_i \in Y={-1, +1}$，$i=1,2,…，N$，则&emsp;&emsp;（1）存在满足条件$\begin{Vmatrix}\hat{\omega _{opt}}\end{Vmatrix}=1$的超平面$\hat{\omega _{opt}\cdot \hat{x}=\omega _{opt}\cdot x + b_{opt}=0$将训练数据集完全分开；且存在$\gamma &gt;0$，对所有$i=1,2,…，N$，有$$y_i (\hat{\omega _{opt}\cdot \hat{x_i})=y_i(\omega _{opt}\cdot x_i + b_{opt})\geq \gamma $$&emsp;&emsp;（2）令$R=\max \begin{Vmatrix}\hat{x_i}\end{Vmatrix}$，则原始感知机算法在训练数据集上的误分类次数$k$满足不等式$$k\leq (\frac{R}{\gamma })^2$$&emsp;&emsp;这个定理表示，误分类次数是有上界的，所以当训练数据集线性可分时，感知机学习算法的原始形式的收敛的。 感知机学习算法的对偶形式&emsp;&emsp;感知机的对偶形式的基本思想是，将参数$\omega ,b$用实例$x_i$和标记$y_i$的线性组合表示，通过求解其系数而得到参数$\omega ,b$。$$\omega =\sum_{i=1}^{N}\alpha _iy_ix_i$$$$b=\sum_{i=1}^{N}\alpha _i y_i$$ 感知机学习算法的对偶形式输入：训练数据集$T={(x_1,y_1),(x_2,y_2),…,(x_N,y_N)}$，其中$x_i \in X=R^n$，$y_i \in Y={-1, +1}$，$i=1,2,…，N$，学习率$\eta (0 &lt; \eta \leq 1)$;输出：$\omega ,b$；感知机模型$f(x)=sign(\omega \cdot x + b)$其中，$\alpha =(\alpha _1,\alpha _2,…,\alpha _N)^T$(1) 初始化$\alpha \leftarrow 0,b\leftarrow 0$(2) 在训练集中选取数据$(x_i, y_i)$ （2、3两步是根据误分类点调整参数，一般我们选点还是按照1至N的顺序选）(3) 如果$y_i(\sum_{N}^{j=1}\alpha _jy_jx_j\cdot x_i+b)\leq 0$$$\alpha _i\leftarrow \alpha _i+\eta $$$$b\leftarrow b +\eta y_i$$(4) 转至(2)，直至训练集中没有误分类点 &emsp;&emsp;在计算的时候，可以预先计算出训练集中实例之间的内积存储在矩阵中，这个矩阵就是Gram矩阵。]]></content>
      <categories>
        <category>《统计学习方法》</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>《统计学习方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016及2013复试上机]]></title>
    <url>%2F2017%2F09%2F12%2F%E4%BF%9D%E7%A0%94%2F2016%E5%8F%8A2013%E5%A4%8D%E8%AF%95%E4%B8%8A%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[2016年保研上机题题目&emsp;&emsp;0. 请从服务器将两个数据文件input.txt和words.txt下载到本地电脑的D盘根文件夹。&emsp;&emsp;1. 在D盘根文件夹的words.txt中存储了不超过30000条的英文单词，每个单词占一行。单词的最大长度为20，且单词内部没有空格，文件中无重复单词。&emsp;&emsp;2. 在D盘根文件夹的input.txt中存储了一个“丢失”了空格和标点符号的英文文章。每行不超过128个字符，请编写程序把该文章中的第一行和最后一行。&emsp;&emsp;4. 编写程序利用words.txt中的单词作为词典，采用正向最大匹配切分单词算法对input.txt中的文本进行单词切分。切分时单词区分大小写，切分分割标记采用空格，并将切分后的结果写入到out.txt中。&emsp;&emsp;5. 编写程序实现步骤2、3描述的要求，并通过如下所示的主函数对进行验证，注意：除了指定添加的代码之外，不得修改main函数其余部分。对main函数每修改一处，总分扣3分，最多扣10分。&emsp;&emsp;6. 本次考试考核C语言程序设计，因此不可以使用C++的STL的任何功能，如果需要添加下面样例之外的程序头文件，请举手得到监考老师批准。 分析&emsp;&emsp;一直说苏大的nlp比较好，所以就出了一道分词。其实做下来这么些年的上机题，发现常出现的有两个：文件操作、素数和字典树。&emsp;&emsp;这道题给了主函数，主函数给了一个数组给我存放字典，但我犹豫了许久还是在这个数组的基础上建立了字典树。虽然一开始对字典树的一些操作比较麻烦，还差一点就没能在两个小时内完成，但性能确实提高了不少。&emsp;&emsp;程序大概分为如下几个部分：&emsp;&emsp;（1）读取文件，显示第一行和最后一行。&emsp;&emsp;（2）读取单词。&emsp;&emsp;（3）根据读取的结果建立字典树。&emsp;&emsp;（4）遍历字典树，进行单词划分。&emsp;&emsp;另外：给的input.txt有非英文字符，需注意。&emsp;&emsp;这里纠正一个错误，C语言不允许在结构体里面写函数（毛大佬教我的），这里的函数还是拿出来比较好。但是代码我就不改了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193//姓名：//学号://具体解决思路描述：#include &lt;time.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define SIZE 30000struct Trienode&#123; char c; Trienode * child[52]; // 前26个为小写，后26个为大写 int scount; void initNode() &#123; for (int i = 0; i &lt; 52; i++) &#123; child[i] = NULL; &#125; scount = 0; &#125;&#125;;void showFirstAndLastLine(char * filename);int ReadWords(char * filename, char words[][24]);Trienode* buildTrieTree(char words[][24], int count);void divideWords(Trienode * head, char filename1[], char filename2[]);int main()&#123; char words[SIZE][24]; clock_t start, finish; start = clock(); showFirstAndLastLine("d:\\input.txt"); //将input文件的第一行和最后一行显示在屏幕上 int count = ReadWords("d:\\words.txt", words); //读取英文字典，并返回单词数量 //此处可以添加处理逻辑以实现题目的第3点要求 //建议将需要的功能实现为多个函数后在此直接或者间接调用 Trienode * head = buildTrieTree(words, count); divideWords(head, "d:\\input.txt", "d:\\out.txt"); finish = clock(); printf("Total time:%lf\n", (double)(finish - start) / CLOCKS_PER_SEC); return 0;&#125;void showFirstAndLastLine(char * filename)&#123; char sen[128], temp[128]; FILE *fp = fopen(filename, "r"); int count = 0; if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; while (fscanf(fp, "%s", sen) != EOF) &#123; if (count == 0) &#123; printf("First line:%s\n", sen); &#125; strcpy(temp, sen); count++; &#125; printf("Last line:%s\n", temp); fclose(fp);&#125;int ReadWords(char * filename, char words[][24])&#123; int count = 0; char w[24]; FILE *fp = fopen(filename, "r"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; while (fscanf(fp, "%s", w) != EOF&amp;&amp; count &lt; SIZE) &#123; strcpy(words[count], w); count++; &#125; fclose(fp); return count;&#125;Trienode* buildTrieTree(char words[][24], int count)&#123; Trienode * head = (Trienode *)malloc(sizeof(Trienode)); Trienode * n, *p; head-&gt;initNode(); for (int i = 0; i &lt; count; i++) &#123; int j = 0; p = head; while (words[i][j] != '\0') &#123; if (words[i][j] &gt;= 'a' &amp;&amp; words[i][j] &lt;= 'z') &#123; if (p-&gt;child[words[i][j] - 'a'] == NULL) &#123; n = (Trienode *)malloc(sizeof(Trienode)); n-&gt;c = words[i][j]; n-&gt;initNode(); p-&gt;child[words[i][j] - 'a'] = n; &#125; p = p-&gt;child[words[i][j] - 'a']; &#125; else &#123; if (p-&gt;child[words[i][j] - 'A' + 26] == NULL) &#123; n = (Trienode *)malloc(sizeof(Trienode)); n-&gt;c = words[i][j]; n-&gt;initNode(); p-&gt;child[words[i][j] - 'A' + 26] = n; &#125; p = p-&gt;child[words[i][j] - 'A' + 26]; &#125; j++; &#125; p-&gt;scount++; &#125; return head;&#125;void divideWords(Trienode * head, char filename1[], char filename2[])&#123; FILE *f1 = fopen(filename1, "r"); FILE *f2 = fopen(filename2, "w"); if (f1 == NULL || f2 == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; char sen[128]; Trienode *p, *t; int len, startlen; while (fscanf(f1, "%s", sen) != EOF) &#123; len = strlen(sen); for (int i = 0; i &lt; len; i++) &#123; t = NULL; p = head; for (int j = i; j &lt; len; j++) &#123; if (sen[j] &gt;= 'a' &amp;&amp; sen[j] &lt;= 'z') &#123; if (p-&gt;child[sen[j] - 'a'] == NULL) &#123; break; &#125; else &#123; p = p-&gt;child[sen[j] - 'a']; if (p-&gt;scount &gt; 0) &#123; t = p; &#125; &#125; &#125; else&#123; if (sen[j] &gt;= 'A' &amp;&amp; sen[j] &lt;= 'Z') &#123; if (p-&gt;child[sen[j] - 'A' + 26] == NULL) &#123; break; &#125; else &#123; p = p-&gt;child[sen[j] - 'A' + 26]; if (p-&gt;scount &gt; 0) &#123; t = p; &#125; &#125; &#125; &#125; &#125; p = head; while (p != t) &#123; if (sen[i] &gt;= 'a' &amp;&amp; sen[i] &lt;= 'z') &#123; p = p-&gt;child[sen[i] - 'a']; fprintf(f2, "%c", sen[i]); &#125; else &#123; if (sen[i] &gt;= 'A' &amp;&amp; sen[i] &lt;= 'Z') &#123; p = p-&gt;child[sen[i] - 'A' + 26]; fprintf(f2, "%c", sen[i]); &#125; &#125; i++; &#125; fputc(' ', f2); i--; &#125; &#125; fclose(f1); fclose(f2);&#125; 2016年复试上机题题目&emsp;&emsp;文本文件input.txt由若干英文单词和分隔符（空格，回车，换行）构成。根据如下说明编写程序统计不同单词出现的次数（频度）。将统计结果按出现频度从高到低排序，并将出现频度大于5的单词及其频度输出到文件output.txt中。&emsp;&emsp;说明：&emsp;&emsp;(1) 多个连续的分隔符被视为一个分隔符。&emsp;&emsp;(2) 单词大小写敏感。&emsp;&emsp;(3) 每个单词的长度不超过20个字符。&emsp;&emsp;(4) 单词的数量未知。如使用定义静态大数组的方式来统计，将被扣除5分。 分析&emsp;&emsp;这个比起上面的保研题目就简单了很多。程序大概分为三个部分：&emsp;&emsp;（1）读文件，保存成字典树。&emsp;&emsp;（2）创建链表，进行排序。&emsp;&emsp;（3）输出结果。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;struct Trienode&#123; char c; Trienode * child[52]; int scount; void initNode() &#123; for (int i = 0; i &lt; 52; i++) &#123; child[i] = NULL; &#125; scount = 0; &#125;&#125;;struct Wordnode&#123; char wds[20]; int wcount; Wordnode * next;&#125;;Trienode * fileRead(char filename[]);void sortWord(Trienode * tnode, Wordnode * whead, char w[], int len);void showData(Wordnode * whead, char filename[], int k);void freeSpace(Trienode * tnode);void freeSpace(Wordnode * whead);int main()&#123; Trienode * thead = fileRead("d:\\input.txt"); Wordnode * whead = (Wordnode *)malloc(sizeof(Wordnode)); char w[20]; memset(w, '\0', sizeof(w)); whead-&gt;next = NULL; for (int i = 1; i &lt; 52; i++) &#123; sortWord(thead-&gt;child[i], whead, w, 0); &#125; showData(whead, "d:\\out.txt", 5); // 释放空间 freeSpace(thead); freeSpace(whead); return 0;&#125;Trienode * fileRead(char filename[])&#123; FILE * fp = fopen(filename, "r"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; char word[20]; Trienode * head = (Trienode *)malloc(sizeof(Trienode)); Trienode * p, *n; head-&gt;initNode(); while (fscanf(fp, "%s", word) != EOF) &#123; p = head; for (int i = 0; word[i] != '\0'; i++) &#123; if (word[i] &gt;= 'a'&amp;&amp;word[i] &lt;= 'z') &#123; if (p-&gt;child[word[i] - 'a'] == NULL) &#123; n = (Trienode *)malloc(sizeof(Trienode)); n-&gt;c = word[i]; n-&gt;initNode(); p-&gt;child[word[i] - 'a'] = n; &#125; p = p-&gt;child[word[i] - 'a']; &#125; else &#123; if (word[i] &gt;= 'A'&amp;&amp;word[i] &lt;= 'Z') &#123; if (p-&gt;child[word[i] - 'A' + 26] == NULL) &#123; n = (Trienode *)malloc(sizeof(Trienode)); n-&gt;c = word[i]; n-&gt;initNode(); p-&gt;child[word[i] - 'A' + 26] = n; &#125; p = p-&gt;child[word[i] - 'A' + 26]; &#125; &#125; &#125; p-&gt;scount++; &#125; fclose(fp); return head;&#125;void sortWord(Trienode * tnode, Wordnode * whead, char w[], int len)&#123; if (tnode == NULL) &#123; return; &#125; Wordnode *p, *q; w[len] = tnode-&gt;c; if (tnode-&gt;scount &gt; 0) &#123; q = whead; p = whead-&gt;next; while (p != NULL) &#123; if (p-&gt;wcount &lt; tnode-&gt;scount) &#123; break; &#125; q = p; p = p-&gt;next; &#125; Wordnode *n = (Wordnode *)malloc(sizeof(Wordnode)); strcpy(n-&gt;wds, w); n-&gt;wcount = tnode-&gt;scount; q-&gt;next = n; n-&gt;next = p; &#125; for (int i = 0; i &lt; 52; i++) &#123; sortWord(tnode-&gt;child[i], whead, w, len + 1); &#125; w[len] = '\0';&#125;void showData(Wordnode * whead, char filename[], int k)&#123; FILE * fp = fopen(filename, "w"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(0); &#125; Wordnode *p = whead-&gt;next; while (p != NULL &amp;&amp; p-&gt;wcount &gt; 5) &#123; fprintf(fp,"%s，%d\n",p-&gt;wds,p-&gt;wcount); p = p-&gt;next; &#125; fclose(fp);&#125;void freeSpace(Trienode * tnode)&#123; if (tnode == NULL) &#123; return; &#125; for (int i = 0; i &lt; 52; i++) &#123; freeSpace(tnode-&gt;child[i]); &#125; free(tnode);&#125;void freeSpace(Wordnode * whead)&#123; Wordnode * p = whead-&gt;next, *q = whead; while (p != NULL) &#123; free(q); q = p; p = p-&gt;next; &#125; free(q);&#125; 2013复试上机题目Introduction&emsp;&emsp;The project will read flight data from an input file and flight path requests from another input file and output the required information. Your Task&emsp;&emsp;Your program should determine if a particular destination airport can be reached from a particular originating airport within a particular number of hops.&emsp;&emsp;A hop (leg of a flight) is a flight from one airport to another on the path between an originating and destination airports.For example, the flight plan from PVG to PEK might be PVG → CAN → PEK. So PVG → CAN would be a hop and CAN → PEK would be a hop. Input Data FilesPath Input File(PathInput.txt)&emsp;&emsp;This input file will consist of a number of single origination/destination airport pairs (direct flights). The first line of the file will contain an integer representing the total number of pairs in the rest of the file.6[PVG, CAN][CAN, PEK][PVG, CTU][CTU, DLC][DLC, HAK][HAK, LXA] Path Request File(PathRequest.txt)&emsp;&emsp;This input file will contain a sequence of pairs of origination/destination airports and a max number of hops. The first line of the file will contain an integer representing the number of pairs in the file.2[PVG, DLC, 2][PVG, LXA, 2] Output File(Output.txt)&emsp;&emsp;For each pair in the Path Request File, your program should output the pair followed by “YES” or “NO” indicating that it is possible to get from the origination to destination airports within the max number of hops or it is not possible, respectively.[PVG, DLC, YES][PVG, LXA, NO] Assumptions you can make:You may make the following simplifying assumptions in your project:&emsp;&emsp;C/C++ is allowed to be used.&emsp;&emsp;All airport codes will be 3 letters and will be in all caps&emsp;&emsp;Origination/destination pairs are unidirectional. To indicate that both directions of flight are possible, two entries would appear in the file. For example, [PVG, PEK] and [PEK, PVG] would have to be present in the file to indicate that one could fly from Shanghai to Beijing and from Beijing to Shanghai. 分析&emsp;&emsp;这是一道英文题目，但是总体上说不难理解。其实就是给一组路径数据，然后求解在给定距离大小内是否能到达目标结点。这有些像图里面的求解单源点的最短路径，但是题目中的图是一张无权图，所以求解会更简单一点。&emsp;&emsp;程序大概分成以下几个部分：&emsp;&emsp;（1）读文件，构造邻接矩阵。还需要有额外的矩阵保存城市名称和城市数量。当然这里用邻接表也可以。说到邻接矩阵，其实邻接矩阵本身可以用来求解，即邻接矩阵的$n$次方的第$i$行第$j$列的数字就是结点$i$到结点$j$走$n$步可以用的方案数。按理说可以用这种方法求解，但是关于矩阵的计算和保存我还没有仔细想。&emsp;&emsp;（2）读需求文件，邻接矩阵深度优先遍历求解。一般来说无向图求解最短路径是用宽度优先遍历，但是这我用的C，不想自己写队列的函数，还有这道题并不要求求出最短路径长度，所以我用了深度优先遍历。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAXCITY 100int cityIndex(char city[][4], char name[], int citynum);int pathRead(char filename[], int matrix[][100], char city[][4], int * citynum);bool isAvailable(int matrix[][100], int m, int n, int hops, int citynum, int maxhops, int flag[]);void requestRead(char infile[], char outfile[], int matrix[][100], char city[][4], int citynum);void main()&#123; int matrix[MAXCITY][MAXCITY] = &#123; 0 &#125;;//邻接矩阵 char city[MAXCITY][4]; int citynum = 0; int pathnum = pathRead("PathInput.txt", matrix, city, &amp;citynum); requestRead("PathRequest.txt", "Out.txt", matrix, city, citynum);&#125;int pathRead(char filename[], int matrix[][100], char city[][4], int * citynum)&#123; FILE * fp = fopen(filename, "r"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; int pathnum = 0; char cityname[4]; char temp; int m, n; if (fscanf(fp, "%d", &amp;pathnum) != EOF) &#123; temp = fgetc(fp); for (int i = 0; i &lt; pathnum; i++) &#123; temp = fgetc(fp); fgets(cityname, 4, fp); if ((m = cityIndex(city, cityname, *citynum)) == -1) &#123; strcpy(city[* citynum], cityname); m = *citynum;; *citynum = *citynum + 1; &#125; temp = fgetc(fp); temp = fgetc(fp); fgets(cityname, 4, fp); temp = fgetc(fp); temp = fgetc(fp); if ((n = cityIndex(city, cityname, *citynum)) == -1) &#123; strcpy(city[*citynum], cityname); n = *citynum; *citynum = *citynum + 1; &#125; matrix[m][n] = 1; &#125; &#125; fclose(fp); return pathnum;&#125;int cityIndex(char city[][4], char name[], int citynum)&#123; for (int i = 0; i &lt; citynum; i++) &#123; if (strcmp(city[i], name) == 0) &#123; return i; &#125; &#125; return -1;&#125;void requestRead(char infile[],char outfile[],int matrix[][100],char city[][4],int citynum)&#123; FILE * f1 = fopen(infile, "r"); FILE * f2 = fopen(outfile, "w"); if (f1 == NULL || f2 == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; int requestnum = 0; char temp, cityname1[4], cityname2[4]; int m, n, maxhops; int flag[MAXCITY]; if (fscanf(f1, "%d", &amp;requestnum) != EOF) &#123; temp = fgetc(f1); for (int i = 0; i &lt; requestnum; i++) &#123; temp = fgetc(f1); fgets(cityname1, 4, f1); temp = fgetc(f1); temp = fgetc(f1); fgets(cityname2, 4, f1); temp = fgetc(f1); temp = fgetc(f1); fscanf(f1, "%d", &amp;maxhops); temp = fgetc(f1); temp = fgetc(f1); if ((m = cityIndex(city, cityname1, citynum)) == -1 || (n = cityIndex(city, cityname2, citynum)) == -1) &#123; fprintf(f2, "[%s, %s, NO]\n", cityname1, cityname2); &#125; else &#123; memset(flag, '\0', sizeof(flag)); if (isAvailable(matrix, m, n, 1, citynum, maxhops, flag)) &#123; fprintf(f2, "[%s, %s, YES]\n", cityname1, cityname2); &#125; else &#123; fprintf(f2, "[%s, %s, NO]\n", cityname1, cityname2); &#125; &#125; &#125; &#125; fclose(f1); fclose(f2);&#125;bool isAvailable(int matrix[][100], int m,int n,int hops,int citynum,int maxhops,int flag[])&#123; if (hops &gt; maxhops) &#123; return false; &#125; if (matrix[m][n] == 1) &#123; return true; &#125; flag[m] = 1; for (int i = 0; i &lt; citynum; i++) &#123; if (matrix[m][i] == 1 &amp;&amp; flag[i] == 0 &amp;&amp; isAvailable(matrix, i, n, hops + 1, citynum, maxhops, flag)) &#123; return true; &#125; &#125; flag[m] = 0; return false;&#125;]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2012-2014年上机复试题]]></title>
    <url>%2F2017%2F09%2F11%2F%E4%BF%9D%E7%A0%94%2F2012-2014%E5%B9%B4%E4%B8%8A%E6%9C%BA%E5%A4%8D%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2012年上机题题目&emsp;&emsp;从服务器上下载数据文件org.dat文件以二进制方式存放一系列整数，每个整数占4个字节。从第一个整数开始，第一个整数和第二个整数构成一个坐标点，依次类推，数据文件中保存了许多坐标点数据。&emsp;&emsp;问题1：&emsp;&emsp;规定处于第一象限的坐标点为有效点，请问数据文件中所有点的个数n为多少？有效点的个数k为多少？&emsp;&emsp;问题2：&emsp;&emsp;每个有效点与坐标原点构成一个的矩形，请问k个有效点与坐标原点构成的k个矩形的最小公共区域面积为多少？&emsp;&emsp;问题3：&emsp;&emsp;寻找有效点中符合下列条件的点：以该点为坐标原点，其他有效点仍然是有效点即处于第一象限（不包括坐标轴上的点）。输出这些点。&emsp;&emsp;问题4：&emsp;&emsp;对所有有效点进行分组，每个有效点有且只能属于一个分组，分组内的点符合下列规则：若对组内所有点的x坐标进行排序，点p1（x1，y1）在点p2（x2，y2）后面，即x1&gt;x2那么y1&gt;y2.请输出所有的分组。 分析&emsp;&emsp;我看到有的代码是分题做的，这样更好给分，但是我就混在一起了，因为有些功能可以同时完成。&emsp;&emsp;我大概分成下面几个部分：&emsp;&emsp;（1）读文件，求出n和k，保存有效点。&emsp;&emsp;（2）以x的的大小由小到大进行排序。经过简单处理。可以得到最小公共面积和问题三所求的点。&emsp;&emsp;（3）分组。我就遍历了，对每个点给了一个符号位。时间复杂度比较高。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void fileRead(FILE * fp, int num[][2], int *k, int * n);int cmp(const void* a, const void *b);void findMinSquare(int num[][2], int k);int divideGroup(int num[][2], int k, int group[]);void main()&#123; FILE * fp = fopen("org.dat", "rb"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; // 造数据文件，coor.txt中已经存放了一些数据 //FILE * fp = fopen("org.dat", "wb"); //FILE * f2 = fopen("coor.txt","r"); //if (fp == NULL || f2==NULL) &#123; // printf("FILE OPEN ERROR!\n"); // exit(1); //&#125; //int t; //while (fscanf(f2, "%d", &amp;t) != EOF) &#123; // fwrite(&amp;t, sizeof(int), 1, fp); //&#125; //fclose(f2); int num[1000][2], k = 0, n = 0, groupnum; int group[100]; fileRead(fp, num, &amp;k, &amp;n); printf("所有点的个数为：%d\n", n); printf("支配点的个数为：%d\n", k); qsort(num, k, sizeof(num[0]), cmp); findMinSquare(num, k); memset(group, -1, sizeof(group)); groupnum = divideGroup(num, k, group); printf("共分为%d组，具体如下：\n", groupnum); for (int i = 0; i &lt; groupnum; i++) &#123; printf("第%d组点为：", groupnum); for (int j = 0; j &lt; k; j++) &#123; if (group[j] == i) &#123; printf(" (%d, %d)", num[j][0], num[j][1]); &#125; &#125; printf("\n"); &#125; fclose(fp);&#125;void fileRead(FILE * fp, int num[][2], int *k, int * n) &#123; int x, y; while (fread(&amp;x, sizeof(int), 1, fp) &amp;&amp; fread(&amp;y, sizeof(int), 1, fp)) &#123; *n = *n + 1; if (x &gt; 0 &amp;&amp; y &gt; 0) &#123; num[*k][0] = x; num[*k][1] = y; *k = *k + 1; &#125; &#125;&#125;int cmp(const void* a, const void *b)&#123; return ((int *)a)[0] - ((int *)b)[0];&#125;void findMinSquare(int num[][2], int k)&#123; int minx, miny; if (k == 1) &#123; printf("最小公共面积是：%d\n", num[0][0] * num[0][1]); printf("符合要求的点的坐标为：(%d, %d)", num[0][0], num[0][1]); &#125; else &#123; if (num[0][0] &lt; num[1][0] &amp;&amp; num[0][1] &lt; num[1][1]) &#123; printf("最小公共面积是：%d\n", num[0][0] * num[0][1]); printf("符合要求的点的坐标为：(%d, %d)\n", num[0][0], num[0][1]); &#125; else &#123; minx = num[0][0]; miny = num[0][1]; for (int i = 1; i &lt; k; i++) &#123; if (minx &gt; num[i][0]) &#123; minx = num[i][0]; &#125; if (miny &gt; num[i][1]) &#123; minx = num[i][1]; &#125; &#125; printf("最小公共面积是：%d\n", minx * miny); printf("没有符合要求的点的坐标。\n"); &#125; &#125;&#125;int divideGroup(int num[][2], int k, int group[])&#123; int groupnum = 0; int tx, ty; for (int i = 0; i &lt; k; i++) &#123; if (group[i] == -1) &#123; group[i] = groupnum; tx = num[i][0]; ty = num[i][1]; for (int j = i + 1; j &lt; k; j++) &#123; if (group[j] == -1 &amp;&amp; num[j][0] &gt; tx &amp;&amp; num[j][1] &gt; ty) &#123; group[j] = groupnum; tx = num[j][0]; ty = num[j][1]; &#125; &#125; groupnum++;; &#125; &#125; return groupnum;&#125; 2013年上机题题目&emsp;&emsp;二进制数据文件1.bin中存放了100000个样本点，每个样本点由4个属性构成，属性均为整型。&emsp;&emsp;定义： 如a点的k个属性不比b点的对应属性差（属性值越小越好），&emsp;&emsp;且a点至少有一个属性比b点的对应属性好，则称a点k-支配b点。&emsp;&emsp;要求： 求出不被任何点k-支配的样本点的个数。&emsp;&emsp;在试卷上填写求出的样本点个数和所用时间（Elapsed Time）。 分析&emsp;&emsp;这道题看上去不难，但是倒是花费了我不少的时间，其中有许多大大小小的bug。先简单介绍一下程序的几个部分：&emsp;&emsp;（1）计时（这个已经写好了）&emsp;&emsp;（2）读取文件中的数据并保存。&emsp;&emsp;（3）遍历数组，寻找不被控制的数据。&emsp;&emsp;我原来打算直接开一个$100000*4$的数组来保存数据，但是报了stack overflow的错，我查了下，说是栈的默认大小是1M，这明显超过了。我就决定用结构体+手动分配内存，但是没想到保存结构体指针的数组也超过了内存限制（原谅我没算）。后来发现只要开成全局变量就好了。&emsp;&emsp;考虑到数据有100000个，昨天丁大佬说10000个数据的话复杂度为$n^2$就有些大了，我就考虑到能不能减少时间复杂度。着就想到了链表。最开始的构想是两层遍历，去掉被控制的点。后来想到为了减少比较的次数，可以设置标志位。既然说到了标志位，就想到不如直接用链表删掉被控制的点就好了。这个算法的时间复杂度我没有求，但是最好情况是$O(n)$，最坏情况是$O(n^2)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#define MAXSIZE 100000void run(void);int main()&#123; LARGE_INTEGER m_nFreq; LARGE_INTEGER m_nBeginTime; LARGE_INTEGER m_nEndTime; QueryPerformanceFrequency(&amp;m_nFreq); QueryPerformanceCounter(&amp;m_nBeginTime); run(); QueryPerformanceCounter(&amp;m_nEndTime); printf("\nElapsed Time = %lf sec\n",(double)(m_nEndTime.QuadPart-m_nBeginTime.QuadPart)/m_nFreq.QuadPart); return 0;&#125;struct Dot&#123; int pos[4]; Dot * next;&#125;;int dataRead(FILE * fp, Dot * head);void eraseControlDot(Dot * head, int * count);void freeSpace(Dot * head);void run(void)&#123; FILE * fp = fopen("1.bin", "rb"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(0); &#125; Dot * head = (Dot *)malloc(sizeof(Dot)); head-&gt;next = NULL; int count = dataRead(fp, head); eraseControlDot(head, &amp;count); printf("%d", count); freeSpace(head); fclose(fp);&#125;int dataRead(FILE * fp, Dot * head)&#123; int count = 0; int a, b, c, d; Dot * node, *p = head; while (fread(&amp;a, sizeof(int), 1, fp) &amp;&amp; fread(&amp;b, sizeof(int), 1, fp) &amp;&amp; fread(&amp;c, sizeof(int), 1, fp) &amp;&amp; fread(&amp;d, sizeof(int), 1, fp ) &amp;&amp; count &lt; MAXSIZE) &#123; node = (Dot *)malloc(sizeof(Dot)); node-&gt;pos[0] = a; node-&gt;pos[1] = b; node-&gt;pos[2] = c; node-&gt;pos[3] = d; node-&gt;next = NULL; p-&gt;next = node; p = node; count++; &#125; return count;&#125;void eraseControlDot(Dot * head, int * count)&#123; Dot *p, *q, *current; if (*count &gt; 0) &#123; current = head-&gt;next; while(current != NULL) &#123; q = head; p = head-&gt;next; while (p != NULL) &#123; if (p-&gt;pos[0] &gt;= current-&gt;pos[0] &amp;&amp; p-&gt;pos[1] &gt;= current-&gt;pos[1] &amp;&amp; p-&gt;pos[2] &gt;= current-&gt;pos[2]&amp;&amp; p-&gt;pos[3] &gt;= current-&gt;pos[3] &amp;&amp;(p-&gt;pos[0] &gt; current-&gt;pos[0] || p-&gt;pos[1] &gt; current-&gt;pos[1] || p-&gt;pos[2] &gt; current-&gt;pos[2] || p-&gt;pos[3] &gt; current-&gt;pos[3])) &#123; q-&gt;next = p-&gt;next; free(p); p = q-&gt;next; *count = *count - 1; &#125; else &#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; current = current-&gt;next; &#125; &#125;&#125;void freeSpace(Dot * head)&#123; Dot *p, *q; p = head-&gt;next; q = head; while (p != NULL) &#123; free(q); q = p; p = p-&gt;next; &#125; free(p);&#125; 2014年上机题题目&emsp;&emsp;input.bin中有10000组数据，每组数据有4个属性，都为整型。定义邻近点为拥有k个距离小于等于d的点的点，$d=\sqrt{(b_1-a_1)*(b_1-a_1)+(b_2-a_2)*(b_2-a_2)+(b_3-a_3)*(b_3-a_3)+(b_4-a_4)*(b_4-a_4)}$;现定义k=10，d=7500，显示出符合点的编号及其各个属性。 分析&emsp;&emsp;这道题就是两次循环求解，不难，但是数据量比较大，时间比较长。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;windows.h&gt;#define ARRAYSIZE 10000#define _CRT_SECURE_NO_WARNINGSstruct Dot &#123; int pos[4]; int ngb; void initDot() &#123; ngb = 0; &#125;&#125;points[ARRAYSIZE];int fileRead(FILE *fp);void countNeighbour(int count, double distance);void showResult(int count, int k);void main()&#123; LARGE_INTEGER m_nFreq; LARGE_INTEGER m_nBeginTime; LARGE_INTEGER m_nEndTime; QueryPerformanceFrequency(&amp;m_nFreq); QueryPerformanceCounter(&amp;m_nBeginTime); FILE * fp = fopen("1.bin", "rb"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; int k=10; double distance=7500; //printf("请输入k和距离："); //scanf("%d%lf", &amp;k, &amp;distance); int count = fileRead(fp); countNeighbour(count, distance); showResult(count, k); fclose(fp); QueryPerformanceCounter(&amp;m_nEndTime); printf("\nElapsed Time=%lf sec\n",(double)(m_nEndTime.QuadPart-m_nBeginTime.QuadPart)/m_nFreq.QuadPart);&#125;int fileRead(FILE *fp)&#123; int num[4]; int count = 0; while (fread(num, sizeof(int), 4, fp) &amp;&amp; count &lt; ARRAYSIZE) &#123; points[count].initDot(); for (int i = 0; i &lt; 4; i++) &#123; points[count].pos[i] = num[i]; &#125; count++; &#125; return count;&#125;void countNeighbour(int count, double distance)&#123; for (int i = 0; i &lt; count - 1; i++) &#123; for (int j = i + 1; j &lt; count; j++) &#123; if (sqrt((double)((points[i].pos[0]-points[j].pos[0])*(points[i].pos[0]-points[j].pos[0]) +(points[i].pos[1] - points[j].pos[1])*(points[i].pos[1] - points[j].pos[1]) +(points[i].pos[2] - points[j].pos[2])*(points[i].pos[2] - points[j].pos[2]) + (points[i].pos[3] - points[j].pos[3])*(points[i].pos[3] - points[j].pos[3]))) &lt; distance) &#123; points[i].ngb++; points[j].ngb++; &#125; &#125; &#125;&#125;void showResult(int count, int k)&#123; bool flag = true; for (int i = 0; i &lt; count; i++) &#123; if (points[i].ngb == k) &#123; printf("第%d个点:(%d,%d,%d,%d)\n",i,points[i].pos[0], points[i].pos[1], points[i].pos[2], points[i].pos[3]); flag = false; &#125; &#125; if (flag) &#123; printf("没有符合要求的点。\n"); &#125;&#125;]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2009-2011年上机复试题]]></title>
    <url>%2F2017%2F09%2F10%2F%E4%BF%9D%E7%A0%94%2F2009-2011%E5%B9%B4%E4%B8%8A%E6%9C%BA%E5%A4%8D%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2009年上机复试题题目&emsp;&emsp;（1）用IE浏览器从FTP上下载org.dat，并保存在D盘的根目录下。&emsp;&emsp;（2）此文件中按文本方式存放了一段其他文章，其中有若干长度小于15的十 进制或八进制数字，数字之间用“,”分开，数字内部存在且仅存在空格。&emsp;&emsp;（3）八进制数以起始位“0”作为标示与十进制数区分。&emsp;&emsp;（4）顺序读取这些数字将他们转变为十进制数后按从大到小的顺序排序后，输 出到D盘根目录下new.txt，每个数字一行。 eg：_235_,34_2,_043_1_,1_3 分别是：十进制235，十进制342.，八进制431，十进制13。_代表空格。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int charToDec(char word[], int m);int cmp(const void *a, const void *b);void main()&#123; FILE * fp1 = fopen("org.dat", "r"); FILE * fp2 = fopen("D:/new.txt", "w"); if (fp1 == NULL || fp2 == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; int num[1000]; char word[20]; char letter; int count = 0, len = 0, val; bool flag = false, first=true; memset(word, '\0', 20 * sizeof(char)); while ((letter = fgetc(fp1)) != EOF) &#123; if (letter == ',') &#123; if (flag) &#123; val = charToDec(word, 8); &#125; else &#123; val = charToDec(word, 10); &#125; memset(word, '\0', 20 * sizeof(char)); len = 0; num[count] = val; count++; first = true; flag = false; val = 0; &#125; else &#123; if (letter &gt;= '0' &amp;&amp; letter &lt;= '9') &#123; if (first) &#123; if (letter == '0') &#123; flag = true; &#125; else &#123; word[len] = letter; len++; first = false; &#125; &#125; else &#123; word[len] = letter; len++; &#125; &#125; &#125; &#125; if (flag) &#123; val = charToDec(word, 8); &#125; else &#123; val = charToDec(word, 10); &#125; num[count] = val; count++; qsort(num,count,sizeof(int),cmp); for (int i = 0; i &lt; count; i++) &#123; fprintf(fp2, "%d\n", num[i]); &#125;&#125;int charToDec(char word[], int m)&#123; int n = 0; for (int i = 0; word[i] != '\0'; i++) &#123; n = n * m + word[i] - '0'; &#125; return n;&#125;int cmp(const void *a, const void *b)&#123; return *(int *)a &lt; *(int *)b ? 1 : -1;&#125; 2010年上机复试题题目&emsp;&emsp;(1)FTP上下载make.exe和org.dat，运行make.exe输入准考证后三位生成data.txt，文件为二进制编码&emsp;&emsp;(2)data.txt内存有2048个整数，其中前n个为非0数，后2048-n个数为0，将其读入数组，计算非零数的个数n&emsp;&emsp;(3)选出n个数中的最大数&amp;最小数&emsp;&emsp;(4)选出n个数中最大素数&emsp;&emsp;(5)将n个数从大到小排序，并平均分成3段（若n非3的整数倍，则不考虑最后的1~2个数），选出中间段的最大数和最小数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#define ARRAYSIZE 2048void fileRead(FILE * fp, int num[], int * n);int cmp(const void * a, const void * b);bool isPreimer(int n);void main()&#123; FILE * fp = fopen("data.txt", "rb"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; int num[ARRAYSIZE], maxnum, minnum, maxpreimer, n; n = 0; memset(num,0,sizeof(num)); fileRead(fp, num, &amp;n); //for (int i = 1; i &lt; 1025; i++) &#123; // fwrite(&amp;i, sizeof(int), 1, fp); //&#125; //int j = 0; /*for (int i = 0; i &lt; 1024; i++) &#123; fwrite(&amp;i, sizeof(int), 1, fp); &#125;*/ qsort(num, n, sizeof(int), cmp); maxnum = num[0]; minnum = num[n - 1]; for (int i = 0; i &lt; n; i++) &#123; if (isPreimer(num[i])) &#123; maxpreimer = num[i]; break; &#125; &#125; printf("非零数字个数为：%d\n", n); printf("其中最大数为：%d\n", maxnum); printf("其中最小数为：%d\n", minnum); printf("其中最大素数为：%d\n", maxpreimer); n = n - n % 3; maxnum = num[n / 3]; minnum = num[n / 3 * 2 - 1]; printf("中间段最大数为：%d\n", maxnum); printf("中间段最小数为：%d\n", minnum);&#125;void fileRead(FILE * fp, int num[], int * n)&#123; int temp; while (fread(&amp;temp, sizeof(int), 1, fp) &amp;&amp; *n &lt; ARRAYSIZE) &#123; if (temp != 0) &#123; num[*n] = temp; *n = *n + 1; &#125; &#125;&#125;int cmp(const void * a, const void * b)&#123; return (*(int *)b - *(int *)a);&#125;bool isPreimer(int n) &#123; if (n &lt;= 1) &#123; return false; &#125; if (n == 2) &#123; return true; &#125; for (int i = 2; i &lt; (sqrt(n*1.0) + 1); i++) &#123; if (0 == n%i) &#123; return false; &#125; &#125; return true;&#125; 2011年上机复试题题目&emsp;&emsp;第一道：输出1000~9999中满足一下条件的所有数：&emsp;&emsp;(1)该数是素数&emsp;&emsp;(2)十位数和个位数组成的数是素数，百位数和个位数组成的数是素数&emsp;&emsp;(3)千位数和百位数组成的数是素数，千位数和十位数组成的数是素数&emsp;&emsp;第二道：&emsp;&emsp;从ftp上下载一个文本info.txt，其中是一段关于计算机历史的英文文档（不过是加过密的，打开看全是乱码），&emsp;&emsp;要求密钥cip1和cip2以及解密后的第一个句子。条件：&emsp;&emsp;(1)cip1和cip2都是八位无符号整数；&emsp;&emsp;(2)加密过程：每次从文本中读出八位字符，然后将该字符和密钥交替异或便是该位置的密文。&emsp;&emsp;如第1个字节与cip1异或，第2个字节和cip2异或，第3个字节和cip1异或，。。。，如此循环至结束。&emsp;&emsp;最后输出cip1和cip2以及第一段完整的英文句子。 分析&emsp;&emsp;第一题不难，只要区分好怎么求一个数的个十百千位就好。第二题我一开始抓到有点懵，似乎有点是n-1个条件求解n个数，这个明显不能求得唯一解啊。但是好在题目给了另外一个条件就是八位无符号整数，那就全都试一遍就好了。在有无符号方面我出了一些bug，毕竟不太熟悉。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;bool isPreimer(int n);void findCode(char letters[], int n, char *cip1, char * cip2);bool isLegalWord(char c);void main()&#123; // 第一题 for (int i = 1000; i &lt; 10000; i++) &#123; if (isPreimer(i) &amp;&amp; isPreimer(i % 100 / 10 + i % 10) &amp;&amp; isPreimer(i % 1000 / 100 + i % 10) &amp;&amp; isPreimer(i / 1000 + i % 1000 / 100) &amp;&amp; isPreimer(i / 1000 + i % 100 / 10)) &#123; printf("%d\n", i); &#125; &#125; // 第二题 // 生成数据文件 /*FILE * fp1 = fopen("data.txt","w"); FILE * fp2 = fopen("result.txt", "r"); if (fp1 == NULL || fp2==NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; char cip1 = 22, cip2 = 10; char t; int count = 1; while (fscanf(fp2, "%c", &amp;t) != EOF) &#123; if (count % 2 == 1) &#123; t = t^cip1; &#125; else &#123; t = t^cip2; &#125; fprintf(fp1,"%c",t); count++; &#125;*/ FILE * fp = fopen("data.txt", "r"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; char letters[10000]; char t; int count = 0; memset(letters, '\0', sizeof(letters)); while (fscanf(fp, "%c", &amp;t) != EOF) &#123; letters[count++] = t; &#125; char cip1, cip2; findCode(letters, count, &amp;cip1, &amp;cip2); for (int i = 0; i &lt; count; i++) &#123; if (i % 2 == 0) &#123; letters[i] = letters[i] ^ cip1; &#125; else &#123; letters[i] = letters[i] ^ cip2; &#125; &#125; printf("cip1:%d\ncip2:%d\n", cip1, cip2); printf("%s\n", letters);&#125;bool isPreimer(int n)&#123; if (n &lt;= 1) &#123; return false; &#125; if (n == 2) &#123; return true; &#125; for (int i = 2; i &lt; (sqrt(n*1.0) + 1); i++) &#123; if (0 == n%i) &#123; return false; &#125; &#125; return true;&#125;void findCode(char letters[], int n, char *cip1, char * cip2)&#123; char t; int j; bool flag1 = true, flag2 = true; for (char i = 0; i &gt;= 0 &amp;&amp; i &lt; 256; i++) &#123; for (j = 0; j &lt; n &amp;&amp; flag1; j = j + 2) &#123; t = i^letters[j]; if (!isLegalWord(t)) &#123; break; &#125; &#125; if (j &gt;= n) &#123; *cip1 = i; flag1 = false; &#125; for (j = 1; j &lt; n &amp;&amp; flag2; j = j + 2) &#123; t = i^letters[j]; if (!isLegalWord(t)) &#123; break; &#125; &#125; if (j &gt;= n) &#123; *cip2 = i; flag2 = false; &#125; &#125;&#125;bool isLegalWord(char c)&#123; if ((c &lt;= 'z'&amp;&amp;c &gt;= 'a') || (c &lt;= 'Z'&amp;&amp;c &gt;= 'A') || c == ',' || c == '.' || c == '?' || c == ';' || c == ':' || c == '!' || c == '\\' || c == '\'' || c == '-' || c == '(' || c == ')' || c == ' ') &#123; return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2008年上机复试题]]></title>
    <url>%2F2017%2F09%2F09%2F%E4%BF%9D%E7%A0%94%2F2008%E5%B9%B4%E4%B8%8A%E6%9C%BA%E5%A4%8D%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2008年上机复试题题目（1）用IE从FTP上下载org.dat，并保存在D盘的根目录中。（2）此文件中按文本方式存放了一段其他文章，其中有若干长度小于15的英 文单词，单词之间用空格分开，无其他符号。（3）顺序读取这段文章的不同的单词（大小写敏感），同时在读取的过程中排除 所有的单词THE以及变形，即这些单词不能出现在读取的结果中。（4）将读取的所有单词的首字母转大写后，输出D根目录下new.txt，每个单词一行。那段文字可以点右键打开方式中用记事本打开，内容是：The constructor is used to initialize the object The destructor is used to delete the Object the calling sequence of constructor is opposite to the calling sequence of destructor运行结果是：ConstructorIsUsedToInitializeObjectDestructorDeleteObjectCallingSeqenceOfOpposite 题目分析&emsp;&emsp;不知道我为什么看到这样的题目第一个反应就是字典树。因为我的C语言写的十分不熟练，所以这种难一点的对我来说就有了无数的Bug。一般的数组也是可以，思想还简单一点，学长给了代码。好像集合也是可以做，但是考虑到可能只给我们用C（虽然他说C++也是可以的，但是我不信），所以最后还是基本用了C。&emsp;&emsp;用字典树的话这道题分成三个部分：&emsp;&emsp;（1）读单词并建树（丁大佬教育我这两个应该分开）：将读到的单词保存，并将它的小写形式与”the”比较。如果不一样的就加入到字典树中。我额外给了一个scount变量表示这个单词有多少个。&emsp;&emsp;（2）字典树遍历：递归遍历字典树，对所有的单词先转换为小写，然后将首字母转为大写输出。&emsp;&emsp;（3）删除字典树并释放指针：递归删除，有点像后序遍历。&emsp;&emsp;需要注意的是一开始读文章中的字母大小写是敏感的，所以一开始建树的时候只能保存单词的原型。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct Trienode&#123; char sletter; int scount; Trienode * child[52]; // 前26个存放小写，后26个存放大写 void initNode()&#123; for (int i = 0; i &lt; 52; i++) &#123; child[i] = NULL; &#125; scount = 0; &#125;&#125;;void treeBuild(Trienode * head, FILE *fp);void treeTraversal(Trienode * node, char * words, int len);void treeDestroy(Trienode * node);void main()&#123; FILE * fp = fopen("org.dat", "r"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; char words[20]; Trienode * head= (Trienode *)malloc(sizeof(Trienode)); head-&gt;initNode(); treeBuild(head, fp); for (int i = 0; i &lt; 52; i++) &#123; treeTraversal(head-&gt;child[i], words, 0); &#125; treeDestroy(head); fclose(fp);&#125;void treeBuild(Trienode * head, FILE *fp)&#123; char temp[20]; Trienode * t; while (fscanf(fp, "%s", temp) != EOF) &#123; t = head; int i = 0; char word[20]; strcpy(word, temp); _strlwr(temp); if (strcmp(temp, "the") != 0) &#123; while (word[i] != '\0') &#123; if (word[i] &gt;= 'a'&amp;&amp; word[i] &lt;= 'z') &#123; if (t-&gt;child[word[i] - 'a'] == NULL) &#123; Trienode * n = (Trienode*)malloc(sizeof(Trienode)); n-&gt;initNode(); n-&gt;sletter = word[i]; t-&gt;child[word[i] - 'a'] = n; t = n; &#125; else &#123; t = t-&gt;child[word[i] - 'a']; &#125; &#125; else &#123; if (t-&gt;child[word[i] - 'A' + 26] == NULL) &#123; Trienode * n = (Trienode*)malloc(sizeof(Trienode)); n-&gt;initNode(); n-&gt;sletter = word[i]; t-&gt;child[word[i] - 'A' +26] = n; t = n; &#125; else &#123; t = t-&gt;child[word[i] - 'A' + 26]; &#125; &#125; i++; &#125; &#125; t-&gt;scount++; &#125;&#125;void treeTraversal(Trienode * node, char * words, int len)&#123; if (node == NULL) &#123; return; &#125; words[len] = node-&gt;sletter; if (node-&gt;scount &gt; 0) &#123; words[len + 1] = '\0'; char temp[20]; strcpy(temp, words); _strlwr(temp); temp[0] = temp[0] + 'A' - 'a'; printf("%s\n", temp); &#125; for (int i = 0; i &lt; 52; i++) &#123; if (node-&gt;child[i] != NULL) &#123; treeTraversal(node-&gt;child[i], words, len + 1); &#125; &#125; words[len] = '\0';&#125;// 删除树void treeDestroy(Trienode * node)&#123; if (node == NULL) &#123; return; &#125; for (int i = 0; i &lt; 52; i++) &#123; treeDestroy(node-&gt;child[i]); &#125; free(node);&#125;]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2005-2007上机复试题]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BF%9D%E7%A0%94%2F2005-2007%E4%B8%8A%E6%9C%BA%E5%A4%8D%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[2005年上机题题目一：把一个数表示成若干个素数的和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;bool isPrime(int n);void divideNum(int n);int count = 0;int main()&#123; divideNum(201); system("pause");&#125;bool isPrime(int n)&#123; if (n &lt;= 1) &#123; return false; &#125; if (n == 2) &#123; return true; &#125; for (int i = 2; i &lt;= sqrt((double)(n)); i++) &#123; if (0 == n%i) &#123; return false; &#125; &#125; return true;&#125;void divideNum(int n)&#123; if (isPrime(n)) &#123; if (count == 0) &#123; printf("n=%d", n); count++; &#125; else &#123; printf("+%d", n); &#125; &#125; else &#123; for (int i = n / 2; i &gt;= 2; i--) &#123; if (isPrime(i)) &#123; if (count == 0) &#123; printf("%d=%d", n, i); count++; &#125; else &#123; printf("+%d", i); &#125; divideNum(n - i); break; &#125; &#125; &#125;&#125; 题目二：统计篇文章中各英文字母的个数，并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct Character&#123; int count = 0; char c;&#125;;int main()&#123; FILE *f1 = fopen("D:\\test.txt", "r"); if (f1 == NULL) &#123; printf("FILE OPEN ERROR!"); exit(1); &#125; Character c[26]; int max; Character temp; for (int i = 0; i &lt; 26; i++) &#123; c[i].c = i + 'a'; &#125; char a; while ((a = getc(f1)) != EOF) &#123; if (a &gt;= 'a' &amp;&amp; a &lt;= 'z') &#123; c[a - 'a'].count++; &#125; if (a &gt;= 'A' &amp;&amp; a &lt;= 'Z') &#123; c[a - 'A'].count++; &#125; &#125; for (int i = 0; i &lt; 25; i++) &#123; max = i; for (int j = i + 1; j &lt; 26; j++) &#123; if (c[max].count &lt; c[j].count) max = j; &#125; if (max != i) &#123; temp.c = c[max].c; temp.count = c[max].count; c[max].c = c[i].c; c[max].count = c[i].count; c[i].c = temp.c; c[i].count = temp.count; &#125; &#125; for (int i = 0; i &lt; 26; i++) &#123; printf("%c: %d\n", c[i].c, c[i].count); &#125; fclose(f1); system("pause"); return 0;&#125; 2006年上机题题目一：找出100到1000内的不含9的素数，存到result文件中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;bool isPrime(int n);bool haveNine(int n);void main()&#123; FILE * fp = fopen("result.txt", "w"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; for (int i = 100; i &lt; 1001; i++) &#123; if (isPrime(i) &amp;&amp; !haveNine(i)) &#123; fprintf(fp, "%d\n", i); &#125; &#125; fclose(fp);&#125;bool isPrime(int n)&#123; if (n &lt;= 1) &#123; return false; &#125; if (n == 2) &#123; return true; &#125; for (int i = 2; i &lt; sqrt((double)(n))+1; i++) &#123; if (0 == n%i) &#123; return false; &#125; &#125; return true;&#125;bool haveNine(int n) &#123; while (n != 0) &#123; if (9 == n % 10) &#123; return true; &#125; n = n / 10; &#125; return false;&#125; 2007年上机题题目一：把10到1000之间满足以下两个条件的数，存到result.txt文件中(1)是素数。(2)它的反数也是素数，如：123的反数是321。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;bool isPrime(int n);int reverse(int n);void main()&#123; FILE *fp = fopen("result.txt", "w"); if (fp == NULL) &#123; printf("FILE OPEN ERROR!\n"); exit(1); &#125; for (int i = 100; i &lt; 1001; i++) &#123; if (isPrime(i) &amp;&amp; isPrime(reverse(i))) &#123; fprintf(fp, "%d\n", i); &#125; &#125; fclose(fp);&#125;bool isPrime(int n)&#123; if (n &lt;= 1) &#123; return false; &#125; if (n == 2) &#123; return true; &#125; for (int i = 2; i &lt; (sqrt((double)(n)) + 1); i++) &#123; if (0 == n%i) &#123; return false; &#125; &#125; return true;&#125;int reverse(int n) &#123; int m = 0; while (n != 0) &#123; m = m * 10 + n % 10; n = n / 10; &#125; return m;&#125;]]></content>
      <categories>
        <category>保研</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[道别]]></title>
    <url>%2F2017%2F07%2F23%2F%E9%9A%8F%E8%AE%B0%2F%E9%81%93%E5%88%AB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我常常会想起和很多人初见的时候，也常常梦见很多新的初见的时刻，但是对很多人，我往往很难想起我们是在哪一刻离开，也许就是渐渐地变成了陌生人。慢慢地，过去种种，似水无痕。&emsp;&emsp;这让我有的时候有些遗憾，对于要离开的人，没有好好地道个别。有的时候只是匆匆忙忙收拾好了行李，走出了宿舍，或是下了车，挥手说一句：“拜”。有些人只是在某次见面后说了一句：“我先走了。”然后就再也没有见过。&emsp;&emsp;突然想到这些是因为今天有个已经毕业的朋友突然给我来了一条消息：“我是来道别的。”早先时候他和我说过，在到了一个新的地方，会删除所有过去的一般朋友的联系方式。我有些诧异，但仍然认认真真与他道了别，祝他以后一切都好，然后看到他消失在我的联系人列表里。我无法评价这个习惯是好或是不好。我只能模模糊糊觉得大概就是从这一刻起，我们就清清楚楚地没有联系了。&emsp;&emsp;但是要问我是否会这么做？我的答案大概是否定的。大概是中国人本性的委婉，让我宁愿自己逐渐淡出别人的生活。比起让我说“道别”二字，大概我只能说一句：“我会想你的。”&emsp;&emsp;最后仍然祝他一切都好吧，也希望那些过去的人也一切都好。 &emsp;&emsp;最后一次更新：某天突然又关注了微博，又开始说奇怪的话。这样子，再看以前就有点可笑了。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell常用命令汇总]]></title>
    <url>%2F2017%2F06%2F22%2Fshell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;其实最开始我也是没有打算写这篇博客的，毕竟网上的相关文档很多，而且对于每个命令我也不打算详细讲，但是期末考要到了，对于命令不熟的我能怎么办啊……我也很绝望啊…… 简单命令 命令 用法 who 列出所有正在使用系统的用户、所用终端名和注册到系统的时间 echo 将命令行中的参数显示到标准输出上 date 显示或设置系统的日期和时间 cal 显示公元1~9999年中任何一年或一个月的日历 clear 清除屏幕上的信息 passwd 和用户口令相关 文件操作命令 命令 用法 cat 连接文件并打印到标准输出设备上 more 显示文件内容，每次显示一屏 less 分屏显示文件内容 head 显示指定文件的开头若干行 tail 显示指定文件末尾若干行 touch 修改指定文件的时间标签或者创建一个空文件 grep 在文件中查找指定模式的词或短语，并输出包括给定字符的所有行 sort 对文本文件各行排序 uniq 从排好序的文件中去除重复行 comm 对两个已经排好序的文件进行比较 diff 比较两个文件，并找出它们的不同 cp 将源文件或目录复制到目标文件或目录中 rm 删除文件和目录 mv 对文件或目录重命名，或者将一个文件从一个目录移到另一个目录中 wc 统计指定文件的字节数、字数、行数，并显示出来 mkdir 创建目录 rmdir 删除目录 cd 改变工作目录 pwd 显示当前工作目录的绝对路径 ls 列出指定目录的内容 ln 创建链接 chmod 改变或设置文件的存取权限 umask 设置新建文件权限的掩码 chgrp 改变文件或目录所属的用户组 chown 改变文件或目录的所有者和所属的组 联机帮助命令 命令 用法 man 命令格式化并显示某一命令的联机帮助手册页 help 查看所有shell内置命令的帮助信息 有关进程管理的命令 命令 用法 ps 查看当前系统中运行的进程信息 kill 终止一个进程的运行 sleep 使进程暂停一段时间 文件压缩和解压缩命令 命令 用法 gzip 对文件进行压缩和解压缩 uzip 对zip格式的压缩文件进行解压缩 其他 命令 用法 history 显示命令历史表中的命令 alias 定义别名 unalias 取消定义的别名 read 读取数据 shift 将命令行的实参左移一位 export 定义一些变量并赋值 set unset 作业控制 命令 用法 jobs 列出当前未完成的作业 bg 把前台作业切换成后台作业 fg 把后台作业切换成前台作业 shell内置命令 命令 用法 eval 进行变量替换，然后执行命令 exec 执行命令，但不创建新的进程 hash 确定并计组指定的命令在搜索路径中的位置 readonly 标记给定的变量是只读的，不能改变其值 trap 设定接收到某个信号完成的动作，忽略某个信号的影响，或者恢复该信号产生时系统预设的动作 type 显示给定命令是如何被解释的 unset 删除指定的相应变量或函数 wait 等待指定的进程终止]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用jupyter notebook进行hexo博客管理]]></title>
    <url>%2F2017%2F06%2F18%2F%E7%94%A8jupyter%20notebook%E8%BF%9B%E8%A1%8Chexo%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我很久都没有再发博客，很大一部分的原因是我总是很懒得切换系统去发博客，而且我的linux输入法有问题每次都需要重装，这让我觉得很痛苦。前几天丁丁给我安利了jupyter notebook，我也恰巧想把博客转成一个随记的地方，就配置了试试。 准备工作&emsp;&emsp;我是在服务器上安装jupyter notebook,系统是Linux。这里有一个官方的安装配置的介绍，可以参考下。 &emsp;&emsp;智障的我一开始以为是本地安装，虽然后面改正了，但是还是被丁丁嘲笑&amp;&amp;嫌弃了。又颠颠地跑去服务器重新配置了下环境，其实就是python和pip，具体的安装命令要是不知道就输入这两个命令，会有提示的。哦，记得要加sudo，我为此还辛辛苦苦找了半天的错 ಥ_ಥ。 安装过程&emsp;&emsp;在安装好pip之后就可以试用一下命令安装jupyter notebook了。1pip install jupyter 配置过程&emsp;&emsp;官方说法是输入以下命令就可以打开一个jupyter notebook的网页了。1jupyter notebook &emsp;&emsp;但是我是服务器啊，还是个没有浏览器的服务器，即使我手动输入网址，也是没有办法访问，所以这时候就需要对jupyter notebook做一些配置，这个过程我参考了丁丁的博客。 &emsp;&emsp;首先是密码部分，你肯定不希望谁都能通过这个端口访问你的文件，苏偶一这时候我们就需要一个密码。按照他博客上说的方法也是可行的，但是jupyter notebook自己就带了可以修改密码的命令，然后输入密码就可以了。1jupyter notebook passwd &emsp;&emsp;在一开始的时候是在找不到jupyter notebook的.config文件的，需要用下面的命令生成一个这样的文件。1jupyter notebook --generate-config &emsp;&emsp;然后就可以通过这个命令对配置进行修改了，在文件中去掉一些注释，然后修改赋值，具体如下：123c.NotebookApp.ip = &apos;*&apos;c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8888 存在的问题&emsp;&emsp;做完以上的这些事情我就可以访问我的jupyter notebook了，但是在访问的过程中存在一个问题，就是对于.md结尾的文件，点击文件名永远是view的界面，但对于txt的文件，就直接是edit的界面。而且对于所有的中文名的文件，点击edit都是无法编辑，显示404错误，但是可以通过将view的界面手动改成edit来修改文件。对于英文名称的文件都是可以编辑的。这个我也很忧桑，丁丁也帮我挣扎了一会儿，无果。要看到这篇博客的各位恰巧知道解决方法的话，拜托联系我下，谢谢。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>jupyter</tag>
        <tag>环境配置</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradient Descent（梯度下降）]]></title>
    <url>%2F2017%2F05%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FGradient%20Descent%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这段时间不是很忙，也看到Andrew Ng在Coursera上的machine learning开课了，就顺带着看看。第一周和第二周讲的都是比较简单的问题，主要就是介绍了Cost Function以及最小化的几个方法。我这里要说的就是其中的一种：Gradient desxcent（梯度下降）。&emsp;&emsp;梯度下降这个概念对很多人来说都不是很熟悉了，我之前看过关于HOG(方向梯度直方图)的一篇论文，再看梯度下降就有种熟悉感。 梯度下降的思想&emsp;&emsp;在介绍梯度下降之前我们先引入一个Cost function（代价函数）：$$J(\theta_0,\theta_1,…,\theta_n)=\frac{1}{2m}\sum_{i=1}^{m}(h(x^i)-y^i)^2$$&emsp;&emsp;$\theta_t$是$x^t$对应的系数，$m$是样本总数，其中$h(x^i)$是第$i$个变量预测的结果，计算公式定义如下：$$h(x^i)=\theta_0+\theta_1x_1+…+\theta_nx_n$$&emsp;&emsp;我们的目的就是最小化$J(\theta_0,\theta_1,…,\theta_n)$的值，这是一个有关于$\theta_0,\theta_1,…,\theta_n$的函数。这也是梯度下降想要求得的目标。&emsp;&emsp;假想我们站在一个山上（当然根据这个题目，这个山可能是多维的，但是不管），我们想要到达海拔最高的地，所以我们的选择是像更矮的地方迈出一步，然后一步一步走到最低点。这也就是梯度下降的思想，根据一定的策略减少$J$的值，然后达到最低点。因为$J(\theta_0,\theta_1,…,\theta_n)$是和$\theta_0,\theta_1,…,\theta_n$有关的函数，所以我们可以通过修改$\theta_0,\theta_1,…,\theta_n$的值来修改$J(\theta_0,\theta_1,…,\theta_n)$的大小。我们以前常用的一种方法就是通过求导来得到最小值所在的位置，梯度下降也是通过求导来逐步修改$\theta_0,\theta_1,…,\theta_n$的值。具体公式如下：$$$$\begin{matrix}\left{\begin{aligned}\theta_0:=\theta_0-\alpha\frac{1}{2m}\sum_{i=1}^{m}(h(x^i)-y^i)\\theta_n:=\theta_n-\alpha\frac{1}{2m}\sum_{i=1}^{m}(h(x^i)-y^i)x^i_n\\end{aligned}\right.\end{matrix}$$$$&emsp;&emsp;其中$\alpha$是学习效率，即我们每次的步子究竟是要迈多大。太小了就会走的很慢，太大了容易一步迈过了最小值，可能离最小值越来越远。通常，我们函数在越靠近最小值时下降越平缓，所以没有必要手动的修改（可以设置为$…0.001,…,0.01,…,0.1,…,1…$）。所以我们每次迭代就是根据不同的$\theta$来计算，再根据不同的计算结果修改$\theta$，至于迭代结束的条件，可以设置两次大小相差不超过$10^{-3}$，或者预先设置好迭代次数。&emsp;&emsp;但是这也带来了一个问题，因为我们身在山中，只知道这个点是我们目前走到的局部最低点，而并不知道是不是想要的全局海拔最低的地方，所以相对应的，梯度下降也是只能得到局部最小值，而不能得到全局最小值。 matlab代码&emsp;&emsp;虽然作业分了单个变量和多个变量，但是因为是用Matlab进行矩阵运算，所以写起来没有多大差别。 梯度下降12345678910111213141516171819202122232425262728function [theta, J_history] = gradientDescent(X, y, theta, alpha, num_iters)%GRADIENTDESCENT Performs gradient descent to learn theta% theta = GRADIENTDESCENT(X, y, theta, alpha, num_iters) updates theta by % taking num_iters gradient steps with learning rate alpha% Initialize some useful valuesm = length(y); % number of training examplesJ_history = zeros(num_iters, 1);for iter = 1:num_iters % ====================== YOUR CODE HERE ====================== % Instructions: Perform a single gradient step on the parameter vector % theta. % % Hint: While debugging, it can be useful to print out the values % of the cost function (computeCost) and gradient here. % h=X*theta; theta=theta-alpha/m*((h-y)'*X)'; % ============================================================ % Save the cost J in every iteration J_history(iter) = computeCost(X, y, theta);endend 计算代价函数1234567891011121314151617181920function J = computeCost(X, y, theta)%COMPUTECOST Compute cost for linear regression% J = COMPUTECOST(X, y, theta) computes the cost of using theta as the% parameter for linear regression to fit the data points in X and y% Initialize some useful valuesm = length(y); % number of training examples% You need to return the following variables correctly J = 0;% ====================== YOUR CODE HERE ======================% Instructions: Compute the cost of a particular choice of theta% You should set J to the cost.h=X*theta;J=1/2/m*(h-y)'*(h-y);% =========================================================================end 特征一般化123456789101112131415161718192021222324252627282930313233343536function [X_norm, mu, sigma] = featureNormalize(X)%FEATURENORMALIZE Normalizes the features in X % FEATURENORMALIZE(X) returns a normalized version of X where% the mean value of each feature is 0 and the standard deviation% is 1. This is often a good preprocessing step to do when% working with learning algorithms.% You need to set these values correctlyX_norm = X;% ====================== YOUR CODE HERE ======================% Instructions: First, for each feature dimension, compute the mean% of the feature and subtract it from the dataset,% storing the mean value in mu. Next, compute the % standard deviation of each feature and divide% each feature by it's standard deviation, storing% the standard deviation in sigma. %% Note that X is a matrix where each column is a % feature and each row is an example. You need % to perform the normalization separately for % each feature. %% Hint: You might find the 'mean' and 'std' functions useful.% mun=mean(X);sigma=std(X);[m,~]=size(X);for i=1:m X_norm(i,:)=(X(i,:)-mun)./sigma;endmu=mun;% ============================================================end &emsp;&emsp;作业及代码放在github了。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为2016研发工程师编程题-数独]]></title>
    <url>%2F2017%2F04%2F07%2F%E5%88%B7%E9%A2%98%2F%E5%8D%8E%E4%B8%BA2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[题目描述&emsp;&emsp;数独是一个我们都非常熟悉的经典游戏，运用计算机我们可以很快地解开数独难题，现在有一些简单的数独题目，请编写一个程序求解。 输入&emsp;&emsp;输入9行，每行为空格隔开的9个数字，为0的地方就是需要填充的。 输出&emsp;&emsp;输出九行，每行九个空格隔开的数字，为解出的答案。 示例输入0 6 0 5 9 3 0 0 0 9 0 1 0 0 0 5 0 0 0 3 0 4 0 0 0 9 0 1 0 8 0 2 0 0 0 4 4 0 0 3 0 9 0 0 1 2 0 0 0 1 0 6 0 9 0 8 0 0 0 6 0 2 0 0 0 4 0 0 0 8 0 7 0 0 0 7 8 5 0 1 0 输出7 6 2 5 9 3 1 4 8 9 4 1 2 7 8 5 3 6 8 3 5 4 6 1 7 9 2 1 9 8 6 2 7 3 5 4 4 7 6 3 5 9 2 8 1 2 5 3 8 1 4 6 7 9 3 8 7 1 4 6 9 2 5 5 1 4 9 3 2 8 6 7 6 2 9 7 8 5 4 1 3 解题思路&emsp;&emsp;网上关于求解数独的题目也有很多方法，比如舞蹈链、摒弃法等等，这些网上都有教程。但是因为时间比较紧，我直接采用了暴力求解的方法，这个方法有以下关键点：&emsp;&emsp; 1. 采用了递归的思想，构造了一个函数solveQues。&emsp;&emsp; 2. 对于输入的9*9的矩阵，直接找到第一个不为0的数（没有则返回true），然后求得这个位置的所有可能性（和所在的行、所在的列、所在的宫里的数字都不冲突），如果可能性为空，则返回false，否则进行枚举，并调用solveQues函数进行递归运算， 如果递归失败，则继续枚举，否则返回true。如果对所有的枚举值都失败，则返回false。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;set&gt;using namespace std;bool solveQues(int question[9][9])&#123; set&lt;int&gt; numpos; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (question[i][j] == 0) &#123; for (int k = 0; k &lt; 9; k++) &#123; numpos.insert(question[i][k]); numpos.insert(question[k][j]); &#125; for (int m = 0; m &lt; 3; m++) &#123; for (int n = 0; n &lt; 3; n++) &#123; numpos.insert(question[i/3*3+m][j/3*3+n]); &#125; &#125; if (numpos.size() == 10) &#123; return false; &#125; for (int k = 1; k &lt; 10; k++) &#123; if (numpos.find(k) == numpos.end()) &#123; question[i][j] = k; if (solveQues(question)) &#123; return true; &#125; &#125; &#125; question[i][j] = 0; return false; &#125; &#125; &#125; return true;&#125;int main()&#123; int a; while (cin &gt;&gt; a) &#123; int question[9][9]; question[0][0] = a; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (i == 0 &amp;&amp; j == 0) &#123; continue; &#125; cin &gt;&gt; question[i][j]; &#125; &#125; if (solveQues(question) )&#123; for (int i = 0; i &lt; 9; i++) &#123; cout &lt;&lt; question[i][0]; for (int j =1; j &lt; 9; j++) &#123; cout &lt;&lt; " "&lt;&lt; question[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 瑕疵&emsp;&emsp;这个代码只输出了一种结果，所以要用它去跑牛客网的题目的话，正确率只有83.33%，有一题有多解，然后我的答案和标准答案不一致，这个我我也很无奈，这个我就不计较了，但是下面有人贴出了一段代码：123456if(data[6][0]==2&amp;&amp;data[6][1]==1&amp;&amp;data[6][2]==3)&#123; data[6][2]=5;data[6][3]=8;data[6][4]=4;data[6][5]=6;data[6][6]=9;data[6][7]=7;data[6][8]=3; data[7][0]=9;data[7][1]=6;data[7][2]=3;data[7][3]=7;data[7][4]=2;data[7][5]=1;data[7][6]=5;data[7][7]=4;data[7][8]=8; data[8][0]=8;data[8][1]=7;data[8][2]=4;data[8][3]=3;data[8][4]=5;data[8][5]=9;data[8][6]=1;data[8][7]=2;data[8][8]=6;&#125; &emsp;&emsp;这个就看看了，只针对题库中的那一种情况，如果真的想A题又不想改代码的人倒可以加上试试。]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为2016研发工程师编程题-字符集合]]></title>
    <url>%2F2017%2F04%2F06%2F%E5%88%B7%E9%A2%98%2F%E5%8D%8E%E4%B8%BA2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目描述&emsp;&emsp;输入一个字符串，求出该字符串包含的字符集合。 输入&emsp;&emsp;每组数据输入一个字符串，字符串最大长度为100，且只包含字母，不可能为空串，区分大小写。 输出&emsp;&emsp;每组数据一行，按字符串原有的字符顺序，输出字符集合，即重复出现并靠后的字母不输出。 示例输入abcqweracb 输出abcqwer 解题思路&emsp;&emsp;这道题我看到的时候就决定用set来写，但是一开始没有看到按照原来的顺序输出，所以WA了一发。后来发现可以不需要用set来保存数据，只需要用set来查重就可以了，也就是输入一个，在set里面找有没有，有就输入下一个，没有就插入到set中，并输出到屏幕上。还有一个特殊的就是我用了字符串流的概念。 代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; char c; while (getline(cin,s)) &#123; set&lt;char&gt; letter; stringstream str(s); set&lt;char&gt;::iterator iter; while (str &gt;&gt; c) &#123; iter = letter.find(c); if (iter == letter.end()) &#123; letter.insert(c); cout &lt;&lt; c; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为2016研发工程师编程题-删数]]></title>
    <url>%2F2017%2F04%2F06%2F%E5%88%B7%E9%A2%98%2F%E5%8D%8E%E4%B8%BA2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98-%E5%88%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我原来是没有打算把做过的题写成博客的，因为大部分还是基础题，而且我往往都是暴力求解，不太优雅。但是做了这道数独题对我还是很有启发的，虽然我仍然用的是暴力求解。做过的很多题有些有着很精巧的解法，但是往往随着时间过去也不太记得了。本地的很多cpp文件总是不能同步带走，而且很多做题的网站查看代码也不是很方便，所以就记录一下权当纪念了。 题目描述&emsp;&emsp;有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0-&gt;1-&gt;2(删除)-&gt;3-&gt;4-&gt;5(删除)-&gt;6-&gt;7-&gt;0(删除),如此循环直到最后一个数被删除。 输入&emsp;&emsp;每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。 输出&emsp;&emsp;一行输出最后一个被删掉的数的原始下标位置。 示例输入8 输出6 解题思路&emsp;&emsp;这道题就是我说的有一些精巧的题，固然是可以用暴力来把删数的过程模拟出来，但是还有更好的递归的方法，虽然我一开始想到的是暴力或者递归的方法，但是最后我还是把递归写成了循环，大概是受到算法作业影响……&emsp;&emsp;假设现在有一串连续的$n$个数$f(n)$：$0,1,2,…,n-2,n-1$，然后我们删掉了其中第$m$个数，那下一次要进行操作的串为$m,m+1,…,n-1,0,1,…,m-2$，我们将它映射到一个新长度为$n-1$的串$f(n-1)$：$0,1,…,n-3,n-2$，表示如下： 原始 新的 m 0 m+1 1 … … 0 n-m 1 n-m+1 … … m-2 n-2 &emsp;&emsp;通过上表我们可以看到两者有如下映射关系：$$原始=(新的+m)/n$$&emsp;&emsp;则$f(n)$最后剩下的数等于$(f(n-1)+m)/n$。那么我们就得到了一个递推的公式，而且当$n=1$时，$f(n)=0$。 代码1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int N; while (cin &gt;&gt; N) &#123; int num = 0; for (int i = 1; i &lt; N; i++) &#123; num = (num + 3) % (i + 1); &#125; cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Offer</category>
      </categories>
      <tags>
        <tag>Offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Harr 小波变换]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Fhaar%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我在网上了解小波变换的时候，发现它是常用于信号处理的一种方法，但是在论文里也常看到小波变换用于图像处理。小波函数在一定的时间间隔内波形幅度的平均值为0。现在有很多小波函数，Haar小波变换函数是其中最基础的一种，是最简单的正交归一化小波 Harr 简介&emsp;&emsp;我们先看一下Harr相关的函数图形： &emsp;&emsp;由上图可以以得知Harr小波函数是一个支撑域(函数$\psi(t)$不为0的区间)在$[0,1]$内的单个矩形波，公式如下：$$\psi(t)=\begin{equation}\left \{\begin{aligned}1 &amp;&amp; 0 \leq x &lt; 0.5\\-1 &amp;&amp; 0.5 \leq x \leq 1\\0 &amp;&amp; otherwise\\\end{aligned}\right.\end{equation}$$ 算法流程Haar小波变换步骤 把小波w(t)和原函数f(t)的开始部分进行比较，计算系数C。系数C表示该部分函数与小波的相似程度。 把小波向右移k单位，得到小波w(t-k)，重复1。重复该部知道函数f结束。 扩展小波w(t)，得到小波w(t/2)，重复步骤1,2。 不断扩展小波，重复1,2,3。 &emsp;&emsp;假设我们现在有一个一维的表示特征的矩阵$X={x_1,x_2,x_3,x_4}$。&emsp;&emsp;然后对这个一维矩阵进行一次变换：$$a_{1,0}=\frac{x_1+x_2}{2}$$$$a_{1,1}=\frac{x_3+x_4}{2}$$$$d_{1,3}=\frac{x_1-x_2}{2}$$$$d_{1,4}=\frac{x_3-x_4}{2}$$&emsp;&emsp;这样可以得到一个一维矩阵$Y={a_{1,0},a_{1,1},d_{1,3},d_{1,4}}$。这里的$a_{1,0}$和$a_{1,1}$分别是$x_1,x_2$和$x_3,x_4$的均分，反映了它们的基本特征，所以我们称之为低频成分；而$d_{1,3}$和$d_{1,4}$分别是$x_1,x_2$和$x_3,x_4$的差值，反映了它们的细节信息，所以我们称之为高频成分。&emsp;&emsp;我们也可以再次运用以上的思想对矩阵$Y$再进行一次Haar小波变换，得到最终的小波系数${a_{2,0},d_{2,1},d_{1,3},d_{1,4}}$。 图像处理中的Harr小波变换&emsp;&emsp;对二维图像进行Haar小波变换有两种方法：标准分解和非标准分解。标准分解是指先使用一维小波对图像的每一行的像素值进行变换,产生每一行像素的平均值和细节系数,然后再使用一维小波对这个经过行变换的图像的列进行变换,产生这个图像的平均值和细节系数。非标准分解是指使用一维小波交替地对每一行和每一列像素值进行变换。&emsp;&emsp;对于对图像做小波变换，可以根据自己的需求编写函数，但是matlab也有自带的小波变换函数：dwt2和wavedec2。其中dwt2是二维单尺度小波变换，其可以通过指定小波或者分解滤波器进行二维单尺度小波分解。而wavedec2是二维多尺度小波分解。dwt2的一种语法格式是[cA,cH,cV,cD]=dwt2(X,’wname’)；而对应的wavedec的语法格式是[C,S]=wavedec2(X,N,’wname’),其中N为大于1的正整数。也就是说dwt2只能对某个输入矩阵X进行一次分解，而wavedec2可以对输入矩阵X进行N次分解。 matlab示例Harr小波示例&emsp;&emsp;虽然matlab有自带的小波变换的函数，也可以通过open或者edit打开函数文件，查看源代码，但是忧伤的是，它的源代码往往互相之间都有联系，我打开了也是看不太懂。所以自己写了一个Haar小波的函数，没有做边界处理，就请将就着看看吧。123456789101112131415function [L,H] = MyHarr( line )% line: 一维矩阵，表示一个信号序列，最好行和列都是2的倍数% L: 低频成分% H: 高频成分n=length(line);n=n/2;L=zeros(1, n);H=zeros(1,n);for i=1:n L(i)=(line(2*i-1)+line(2*i))/2; H(i)=(line(2*i-1)-line(2*i))/2;endend matlab的dwt2()函数&emsp;&emsp;dwt2()函数的一般形式就是： [CA,CH,CV,CD] = dwt2(X,&apos;wname&apos;) CA：approximation coefficients matrix（近似系数矩阵）CH、CV、CD：details coefficients matrices（细节系数矩阵） &emsp;&emsp;使用并显示的代码如下：1234567891011A=imread('lena.jpg');[CA,CH,CV,CD] = dwt2(A,'haar') ;subplot(2,2,1);imshow(uint8(CA));subplot(2,2,2);imshow(uint8(CH));subplot(2,2,3);imshow(uint8(CV));subplot(2,2,4);imshow(uint8(CD)); &emsp;&emsp;显示的效果图为： matlab的wavedec2()函数&emsp;&emsp;wavedec2()一般使用形式为： [C,S] = wavedec2(X,N,&apos;wname&apos;) &emsp;&emsp;这是一种二维多尺度小波分解函数，分解的次数和传入的参数N有关。其中C是一个行向量，它的组成如下： C = [ A(N) | H(N) | V(N) | D(N) | … H(N-1) | V(N-1) | D(N-1) | … | H(1) | V(1) | D(1) ]. &emsp;&emsp;介于这个不太好显示结果，我就不放出matlab代码了，实在需要的话相关的文档中有一段。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
        <tag>单样本人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主成分分析（Principal Component Analysis）]]></title>
    <url>%2F2017%2F03%2F29%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我们在做图像处理的时候，为了避免提取的特征维数太高使得计算速度变慢，可以用下面几种方法降低特征的维数： 在一开始的时候对图片预处理，降低图片本身的维数。 在特征提取的过程中对特征进行处理，降低特征的的维数。（比如对LBP特征进行直方图统计，就有均衡模式的LBP这个方法来降低特征的维数） 采用一些降维德方法。（比如我们要介绍的PCA） 数学理论&emsp;&emsp;PCA降维的思想方法是找到一个投影矩阵，这个矩阵对应了一个维数更低的空间，样本经过和这个投影矩阵运算，可以变成维数更小的矩阵，从而达到投影的目的。至于怎么这过程中的理论推导，用到了很多线性代数的知识，我深觉不能讲的更好，推荐一个现有的教程：PCA数学原理，我从中受益颇多。&emsp;&emsp;然后我们来划一下重点。 问：首先我们的目的是什么呢？ 答：是为了降低矩阵的维度。 问：那么怎么降低维度呢？ 答：我们通过将现有的特征投影到维数更低的空间的基上，将维数高的向量空间用维数低的向量空间的基表示。 问：那么怎么求的我们想要的基呢？ 答：不是随随便便一组基就可以的，我们需要找到在这组基上所有向量的离散度都能最大，即方差最大化，而且我们希望这些基是线性无关的，即它们的协方差为0。我们在计算协方差矩阵（$C=\frac{1}{m}XX^T$）的时候，会发现它的对角线上是对应的是不同维度的方差，而其他位置是一些维度的协方差，而且它是一个对称的矩阵。那么我们通过实矩阵对角化的方式，可以得到这个协方差矩阵对应的特征向量矩阵中的一部分就是我们所要的基。根据特征值的大小，我们将对应的特征矩阵进行排序，得到前k个特征向量组成的矩阵（每个特征向量为一个行向量），即我们所要求得的投影矩阵。 &emsp;&emsp;在这里补充一个链接，其中有个回答我觉得很有意思，大概就是关于和奶奶讲PCA的，讲的很浅显，很有意思，网上也有中文版。 算法步骤&emsp;&emsp;假设有$m$条$n$维数据。 将原始数据按列组成$m$行$n$列矩阵$X$。 将$X$的每一行（代表一个属性字段）进行零均值化，即求得每一行的均值，并将每个元素减去对应行的均值。 求出均值化后的$X$的协方差矩阵$C$，其中$C=\frac{1}{m}XX^T$。 求出协方差矩阵$C$的特征值及对应的特征向量。 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前$k$行组成投影矩阵$P$。 将矩阵$X$和$P$进行运算，得到新矩阵$Y$，其中$Y=PX$。 具体实现matlab实现&emsp;&emsp;我简单实现了一下PCA，学习到了很多新的matlab函数。12345678910111213141516171819202122232425262728293031323334353637383940function [X, P] = PCA( XMat, k, percent )if nargin &lt;1 help PCA;endif nargin &lt; 2 k=0; percent=0.9;endif nargin&lt;3 percent=0.9;end% 对所有特征进行归一化avg=mean(XMat);X_norm = bsxfun(@minus, XMat, avg);% 求协方差矩阵C= cov(X_norm);% 求协方差矩阵的特征值和特征向量[fvec,fvalue]=eig(C);% 将特征向量按对应特征值大小从上到下按行排列成矩阵fvalue=diag(rot90(rot90(fvalue)));fvec=rot90(fvec);% 如果未给出k值，则计算k值sumper=0;t=sum(fvalue);if k==0 while sumper&lt;percent k=k+1; sumper=sumper+fvalue(k)/t; endendP=fvec(1:k,:);X=(P*XMat')';end matlab自带函数princomp()&emsp;&emsp;我在matlab命令行中执行help命令时，得到了如下反馈：123456789101112princomp Principal Components Analysis (PCA). princomp will be removed in a future release. Use PCA instead. Calls to princomp are routed to PCA. [coeff, score, latent, tsquare] = princomp(x,econFlag) See also: PCAprincomp 的参考页 &emsp;&emsp;我更改目录用help pca试了一下，发现matlab本身就有pca函数，而对princomp()函数的调用实际上是调用pca()函数，所以这里关于函数的调用也只有一句说明：1[coeff, score, latent, tsquare] = princomp(x,econFlag) &emsp;&emsp;我在网上看了一些介绍，大致了解了下： x：待处理矩阵，每列是一个维度，每行是一个样本。coeff：原矩阵所对应的协方差阵V的所有特征向量组成的矩阵，即变换矩阵或称投影矩阵。score：对主分的打分，也就是说原矩阵在主成分空间的表示。latent：协方差矩阵的特征值。tsquare：对每个样本点Hotelling的T方统计量。 &emsp;&emsp;跑了一下我写的和matlab自带的pca的效率对比，默默在一旁流泪。 python实现12345678910111213141516import numpy as npdef pca(XMat, k): avg = np.mean(XMat, axis=0)#col average m, n = np.shape(XMat)#m: the number of samples n:the size of vector avgs = np.tile(avg, (m, 1))#create a matrix of m*1, each row is a column average Xadjust=XMat-avgs Xcov=np.cov(Xadjust.T)#cov matrix feaVec, feaVal = np.linalg.eig(Xcov) # feature vector and feature value index=np.argsort(-feaVal) if k&gt;n: print("k must lower than feature number") return selectVec = np.matrix(feaVec.T[index[:k]]) finalData = Xadjust * selectVec.T return selectVec, finalData]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie Tree（字典树）]]></title>
    <url>%2F2017%2F03%2F27%2F%E8%AF%BE%E7%A8%8B%2FTrieTree%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;之前有看到过这个概念，但是没有认真了解过，这次刷hihoCoder的题目看到了这个。&emsp;&emsp;Trie Tree，也就是常说的字典树。它利用了空间换时间的思想，用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，提高查询效率。它是一种多叉树的结构，对它来说，每一个结点由值域和链域两部分组成，值域保存这个结点对应的字符数和以到这个结点的所有的字符组成的字符串为前缀的字符串个数，链域则是指向该结点后继的结点。树的形式极大地减少了比较的次数，便于查找。&emsp;&emsp;对于一个结点来说，链域的存储方式有很多种，我想到了以下几种： 增加一个指针采用，表示该结点的兄弟结点，即“左儿子右兄弟”的形式。（这也是我一开始采用的方法，但是后来逻辑没有理清楚，放弃了） 增加一个指针数组，数组不同位置对应不同的字符。（这是很常用的一种方法，但是我一开始没有看到字符的类别数，也没有采用，但是比第一种简单很多） 增加一个表示指针的map，不同的键值对应不同的结点。（这也是我最后采用的一种方法，用起来也不复杂） &emsp;&emsp;下面的代码是实现hihoCoder的#1014 : Trie树，所以说对于Trie Tree的功能我只实现了插入和查询的部分，具体见下面代码（已AC）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class trieNode &#123;private: int ccount; char letter;public: map &lt;char, trieNode*&gt; nodemap; trieNode() &#123; ccount = 0; &#125; trieNode(char c); void inccount() &#123; ccount++; &#125; int getcount() &#123; return ccount; &#125;&#125;;trieNode::trieNode(char c)&#123; ccount = 1; letter = c;&#125;class trieTree &#123;private: trieNode* head;public: trieTree() &#123; head = new trieNode(); &#125; void trieTreeInsert(string s); int countPrefix(string s);&#125;;void trieTree::trieTreeInsert(string s)&#123; trieNode *p, *q; int len = s.length(); int i; if (len &gt; 0) &#123; p = head; for (i = 0; i &lt; len; i++) &#123; if (p-&gt;nodemap.find(s[i]) == p-&gt;nodemap.end()) &#123; p-&gt;inccount(); break; &#125; else &#123; p-&gt;inccount(); p = p-&gt;nodemap[s[i]]; &#125; &#125; if (i == len) &#123; p-&gt;inccount(); &#125; for (; i &lt; len; i++) &#123; q = new trieNode(s[i]); p-&gt;nodemap.insert(make_pair(s[i], q)); p = q; &#125; &#125;&#125;int trieTree::countPrefix(string s) &#123; int len = s.length(); int count = 0; trieNode *p = head; bool f = true; for (int i = 0; i &lt; len; i++) &#123; if (p-&gt;nodemap.find(s[i]) == p-&gt;nodemap.end()) &#123; f = false; break; &#125; else &#123; p = p-&gt;nodemap[s[i]]; &#125; &#125; if (f) &#123; count = p-&gt;getcount(); &#125; return count;&#125;int main()&#123; int n, m, count; string s; trieTree tr; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s; tr.trieTreeInsert(s); &#125; cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; s; count=tr.countPrefix(s); cout &lt;&lt; count &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>hihoCoder</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>hihoCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆矩阵]]></title>
    <url>%2F2017%2F03%2F25%2F%E8%AF%BE%E7%A8%8B%2F%E9%80%86%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;逆矩阵也是我们在进行矩阵运算时很常用到的一个概念。 相关概念 奇异矩阵：该$n$阶方阵对应的行列式为0.非奇异矩阵：该$n$阶方阵对应的行列式不为0.伴随矩阵：将原矩阵中的所有元素换成该元素对应的代数余子式，并转置得到的矩阵，记为$A^* $。&emsp;&emsp;注意，伴随矩阵有一条重要的性质：$AA^* =A^* A=|A|E$，由此可以推出：$A\frac{A^*}{|A|}=E$ &emsp;&emsp;通过这个方法，我们可以用Matlab求得一个矩阵的伴随矩阵。12345678910&gt;&gt; A=[1,2,3;4,3,5;5,2,3]A = 1 2 3 4 3 5 5 2 3&gt;&gt; inv(A)*det(A)ans = -1.0000 -0.0000 1.0000 13.0000 -12.0000 7.0000 -7.0000 8.0000 -5.0000 可逆矩阵&emsp;&emsp;假设$A$是一个方阵，假设存在一个方阵$B$，满足$AB=BA=E$，那么就称$A$是可逆矩阵，其逆矩阵为$B$。&emsp;&emsp;可逆矩阵有如下几条性质： 若矩阵$A$是可逆的，则$A$的逆矩阵是唯一的。 方阵$A$可逆的充分必要条件是$|A|\neq0$，所以计算逆矩阵也可以通过伴随矩阵：$$A^{-1}=\frac{1}{|A|}A^*$$ 可逆矩阵$A$可以经过有限次初等变换变成单位矩阵。&emsp;&emsp;可以通过初等变换求逆矩阵：$(A|E)\xrightarrow{初等行变换}(E|A^{-1})$ &emsp;&emsp;MATLAB有多种求逆矩阵的方法，下面列出三种。123456789101112131415161718192021&gt;&gt; A=[1,2,3;4,3,5;5,2,3]A = 1 2 3 4 3 5 5 2 3&gt;&gt; inv(A)ans = -0.2500 -0.0000 0.2500 3.2500 -3.0000 1.7500 -1.7500 2.0000 -1.2500&gt;&gt; A^-1ans = -0.2500 -0.0000 0.2500 3.2500 -3.0000 1.7500 -1.7500 2.0000 -1.2500&gt;&gt; E=eye(3);&gt;&gt; E/Aans = -0.2500 -0.0000 0.2500 3.2500 -3.0000 1.7500 -1.7500 2.0000 -1.2500]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行列式]]></title>
    <url>%2F2017%2F03%2F24%2F%E8%AF%BE%E7%A8%8B%2F%E8%A1%8C%E5%88%97%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;讲真我也只是记得这个概念了，计算方法什么的都不太记得了，真是对不起我线性代数的老师。大概也是因为现在都是用的矩阵的运算，行列式接触的比较少吧。不过原来学习过的基础还在，复习起来还是很快的。 行列式的概念二阶行列式&emsp;&emsp;行列式是一种基本的数学工具，行列式理论是由求解n元线性方程组的实际需要建立、发展起来的。&emsp;&emsp;行列式是有一个数值的，最简单的是二阶行列式，二阶行列式计算有一个很简单的公式：$$\left|\begin{array}{cccc} a_{11} &amp; a_{12}\\ a_{21} &amp; a_{22} \end{array}\right|= a_{11}a_{22}-a_{12}a_{21}$$ 余子式和代数余子式&emsp;&emsp;在提到n阶行列式之前先提一下余子式和代数余子式的概念。 余子式：将$a_{ij}$所在的第i行和第j列的所有元素从原先的行列式中划去得到的行列式即为$a_{ij}$的余子式。 代数余子式：在余子式前面添加符号$(-1)^{i+j}$。 &emsp;&emsp;我暂时还没找到相关的直接计算的matlab函数，但自己写来也不难，尤其是后面逆矩阵时候还有直接计算的公式。 拉普拉斯定理&emsp;&emsp;对于高阶的行列式来说，它们的值可以通过低阶的行列式得出，这就是拉普拉斯定理。所以说虽然三阶的行列式也有对角线公式，但是我也没有记，还是更倾向于用公式直接推，也方便得很。拉普拉斯公式如下：$$D=a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}$$&emsp;&emsp;或$$D=a_{1j}A_{1j}+a_{2j}A_{2j}+…+a_{nj}A_{nj}$$&emsp;&emsp;就是指高阶的行列式的值等于它的某一行或者某一列的值乘以它们的代数余子式。所以我们在计算的时候通常会选择0比较多的那一行或者一列进行计算。&emsp;&emsp;而且需要注意的是对于一阶行列式，它的值就等于它的元素本身，而不是元素的绝对值。&emsp;&emsp;在matlab里面可以直接用det()函数求一个n阶行列式的值。12345678&gt;&gt; A=[1,2,3;4,5,2;3,2,4]A = 1 2 3 4 5 2 3 2 4&gt;&gt; det(A)ans = -25 行列式的性质&emsp;&emsp;行列式的性质和矩阵很像，但是不如矩阵随性，。这些性质可以帮助我们更好的求解行列式，具体如下： 行列式与它的转置行列式相等。 互换行列式的两行(列)，行列式变号。&emsp;推论：如果行列式有两行(列)完全相同，则此行列式为零。 行列式的某一行(列)中所有的元素都乘以同一数k，等于用数k乘此行列式。 行列式中如果有两行(列)元素成比例，则此行列式等于零。 把行列式的某一列(行)的各元素乘以同一数然后加到另一列(行)对应的元素上去，行列式不变。 行列式的某一列(行)的各元素与另一列(行)对应的元素的代数余子式之积为零。 方阵的行列式&emsp;&emsp;方阵的行列式具有如下的性质： $|A^T|=|A|$ $|kA|=k^n|A|$ $|AB|=|A||B|$ $|AB|=|BA|$ 克拉默法则&emsp;&emsp;上文中有提到，行列式的产生和多元方程组的求解有关，而这就要提到克拉默法则了。对于一个方程组：$$\begin{equation}\left\{\begin{aligned}a_{11}x_1+a_{12}x_2+…+a_{1n}x_n=b_1\\a_{21}x_1+a_{22}x_2+…+a_{2n}x_n=b_1\\…\\a_{n1}x_1+a_{n2}x_2+…+a_{nn}x_n=b_1\\\end{aligned}\right.\end{equation}$$&emsp;&emsp;当$b_1,b_2,…,b_n$不全为0时，这个方程组就叫非齐次线性方程组；而当$b_1,b_2,…,b_n$全为0时，这个方程组叫齐次线性方程组。&emsp;&emsp;对于上面这种形式的方程组，我们有一种很好的求解变量值的方法——克拉默法则。当然克拉默法则有使用的前提：所有系数组成的行列式D不能为0，仅适用于未知向量个数由于方程个数相等的方程组。&emsp;&emsp;当$D\neq0$时，此方程组有唯一解：$$x_i=\frac{D_i}{D}$$&emsp;&emsp;其中$D_i$表示用列向量$[b_1,b_2,…,b_n]$替换D中第$i$列得到的行列式。&emsp;&emsp;但是在matlab就不用这么麻烦了，直接使用\就好，结果依次对应不同变量的值。1234567&gt;&gt; A=[1,2,3;4,5,2;3,2,4];&gt;&gt; B=[1;2;2];&gt;&gt; A\Bans = 0.4000 0.0000 0.2000]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K近邻分类器]]></title>
    <url>%2F2017%2F03%2F22%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FK%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;K近邻分类器是机器识别中很常用的一种分类方法，以前在做单样本人脸识别的时候常用的最近邻分类方法就是其中k=1的特殊情况。以前都是用matlab写的代码，最近老师动员大家一起来学python，然后我们就都从K近邻算法开始学习编程了。 K近邻算法&emsp;&emsp;该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。其实也很好理解，就是现在有n个训练样本，分别对应c个类，现在有一个未知的测试样本，要找到这个测试样本的类别。K近邻的方法就是计算出每个训练样本和测试样本的距离，找到其中最近的K个样本对应的类别，并统计每个类出现的次数，出现的最多的类即使该测试样本对应的类。 Python代码&emsp;&emsp;这个代码就是随便写写了，我只用了欧氏距离。其实python有自带的KNN的函数，所以还是推荐大家直接调用函数吧。代码若有错误望指正。123456789101112131415161718def knn(trn,label,x,k):import numpy as npdist=np.zeros(numsamples)for i in range(numsamples): dist[i] = np.sqrt(np.sum(np.square(trn[i] - x)))print (dist)index=np.argsort(dist)print (index)numclass=np.max(label)+1times=np.zeros(numclass)for i in range(k): times[label[index[i]]]=times[label[index[i]]]+1 print(times)ind=np.argmax(times)return (label[ind]) 测试：12345678trn1=np.random.randn(10,2)trn2=np.random.randn(10,2)trn=np.concatenate((trn1,trn2))x=np.random.randn(1,2)label=[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1]k=3result=knn(trn,label,x,k)print (resut) matlab代码&emsp;&emsp;matlab我把这个分成了两个部分，计算距离和分类，因为可选的参数有点多。首先是计算距离的函数(discompute.m)：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function [D]=discompute(X_trn,X_tst,method)%%%%%%%%%%%%%%%%%%%%%% 这个函数是来计算训练样本和测试样本之间的距离% X_trn是训练样本，X_tst是测试样本，都是cell矩阵，一个cell存放一张图片% method有四个值可供选择：chi-square（卡方距离）、manhatton（曼哈顿距离）、cosine（余弦距离）、euclidean（欧氏距离）% 返回值D即距离，是cell矩阵，一个cell存放一个测试样本和所有训练样本的距离% 对于D中的每个cell，行对应着不同的块，列对应着不同的训练样本if nargin&lt;3 method='chi-square';endD=cell(length(X_tst),1);switch lower(method) case 'chi-square' for j=1:length(X_tst) x1=X_tst&#123;j&#125;; for i=1:length(X_trn) x2=X_trn&#123;i&#125;; A=(x1-x2).^2./(x1+x2); in=find(isnan(A)==1); A(in)=0; D&#123;j&#125;(:,i)=sum(A,2); % Chi-square distance end end case 'manhattan' for j=1:length(X_tst) x1=X_tst&#123;j&#125;; for i=1:length(X_trn) x2=X_trn&#123;i&#125;; D&#123;j&#125;(:,i)=sum(abs(x1-x2),2); %Mahatton distance end end case 'cosine' for j=1:length(X_tst) x1=X_tst&#123;j&#125;;% [x1]=normlizedata(x1,'1-norm'); for i=1:length(X_trn) x2=X_trn&#123;i&#125;;% [x2]=normlizedata(x2,'1-norm'); D&#123;j&#125;(:,i)=1-(diag(x1*x2')./(sqrt(diag(x1*x1')).*sqrt(diag(x2*x2')))); % Cosine distance end end case 'euclidean' for j=1:length(X_tst) x1=X_tst&#123;j&#125;; for i=1:length(X_trn) x2=X_trn&#123;i&#125;; D&#123;j&#125;(:,i)=(sum(((x1-x2).^2),2)); %Euclidean distance end endend 然后是分类（disclassify.m）:123456789101112131415161718192021222324252627282930313233343536373839404142434445`function [out]=distclassify(D,Y,method,Layer) %%%%%%%%%%%%%%%%%% % 这个函数是用来进行分类的 % 参数D是距离（参见discompute.m），Y是所有训练样本的标签 % method有四个值可选：vote（投票）、min_dist（最小值）、max_dist（最大值）和sum_dist（总和）。 % out返回所有测试样本的标签，是一个行向量 if nargin&lt;2 || nargin&gt;4 help Distclassify else numclass=max(Y); numtest=length(D); if nargin&lt;4 Layer=floor(log(numclass)/log(2));end if nargin&lt;3 method='vote';end switch lower(method) case 'vote' A=zeros(numtest,numclass); for i=1:length(D) [~,d]=min(D&#123;i&#125;'); for j=1:numclass A(i,j)=sum(Y(j)==d); end end [~,out]=max(A'); case 'min_dist' A=zeros(numtest,numclass); for i=1:numtest A(i,:)=min(D&#123;i&#125;); end [~,out]=min(A'); case 'max_dist' A=zeros(numtest,numclass); for i=1:numtest A(i,:)=max(D&#123;i&#125;); end [~,out]=min(A'); case 'sum_dist' A=zeros(numtest,numclass); for i=1:length(D) A(i,:)=sum(D&#123;i&#125;); end [~,out]=min(A'); end end]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matlab</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初等变换与初等矩阵]]></title>
    <url>%2F2017%2F03%2F21%2F%E8%AF%BE%E7%A8%8B%2F%E5%88%9D%E7%AD%89%E7%9F%A9%E9%98%B5%E4%B8%8E%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是在很久之前学的内容了，模模糊糊记得有这种变换，但是详细的不是很记得了，现在看来又学习到了很多。温故而知新嘛。 初等变换&emsp;&emsp;矩阵的初等变换分为初等行变换和初等列变换，列变换和行变换的类型类似，所以这里只提初等行变换了。 对调两行（$ r_i \leftrightarrow r_j$）。 以非零常数k乘以某一行的全部元素($kr_i$)。 将某一行上的全部元素的k倍加到另一行上去（$kr_i+r_j$）。 &emsp;&emsp;通常，我们将初等行变换写在箭头的上方，将初等列变换写在矩阵的下方。经过有限次初等变换得到的新矩阵和原来矩阵是等价的。matlab使用rref()函数来计算矩阵的简化梯形形式。1234567&gt;&gt; A=[16 3 2 13;5 10 11 8;9 6 7 12;4 15 14 1];&gt;&gt; rref(A)ans = 1 0 0 1 0 1 0 -3 0 0 1 3 0 0 0 0 初等矩阵&emsp;&emsp;初等变换可以用初等矩阵表示，初等矩阵即由单位矩阵经过一次初等变换得到的矩阵。 对调两行：&emsp;&emsp;将相应单位矩阵的两行（列）对换。 以非零常数k诚意某一行的全部元素：&emsp;&emsp;将非零常数k乘以单位矩阵的对应的行（列）。 将某一行上的全部元素的k倍加到另一行上去：&emsp;&emsp;将对应的行（列）上的全部元素的k倍加到另一个对应的行（列）。 &emsp;&emsp;对于初等行变换，则把初等矩阵左乘原矩阵；对于初等列变换，则把初等矩阵右乘原矩阵。]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础矩阵概念]]></title>
    <url>%2F2017%2F03%2F21%2F%E8%AF%BE%E7%A8%8B%2F%E5%9F%BA%E7%A1%80%E7%9F%A9%E9%98%B5%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这段时间开始重新学习线性代数，其实这是一门很有用的学科，而且我使用matlab有一段时间了，也是一直在和矩阵打交道，但是常常碰到有些概念还是觉得模糊不清楚，所以重新捡起《线性代数》这门课进行学习。学习过程中也会插入一些matlab实现。 矩阵的特类行矩阵&emsp;&emsp;行矩阵就是只有一行的矩阵，matlab里很常用。 123456&gt;&gt; a=[1,2,3,4]a = 1 2 3 4&gt;&gt; a=[1:4]a = 1 2 3 4 列矩阵&emsp;&emsp;列矩阵就是只有一列的矩阵，因为matlab很多都是列运算，所以我常常更倾向于用列矩阵。 123456&gt;&gt; b=[1;2;3;4]b = 1 2 3 4 上三角矩阵&emsp;&emsp;上三角矩阵主对角线下侧的元素全为0，matlab也有直接取一个矩阵上三角的函数。 1234567&gt;&gt; c=[1:4;2:5;3:6;4:7];&gt;&gt; triu(c)ans = 1 2 3 4 0 3 4 5 0 0 5 6 0 0 0 7 下三角矩阵&emsp;&emsp;下三角矩阵主对角线上侧的元素全为0，matlab也有直接取一个矩阵下三角的函数。 1234567&gt;&gt; c=[1:4;2:5;3:6;4:7];&gt;&gt; tril(c)ans = 1 0 0 0 2 3 0 0 3 4 5 0 4 5 6 7 对角阵&emsp;&emsp;对角阵就是主对角线两侧的元素全为0的方阵，matlab中可用diag(a,n)生成，其中a是向量，n是它偏离对角线的列数，可以为正数也可以为负数。生成对角阵的时候设置n=0，或者直接采用diag(a)就可以了。 1234567&gt;&gt; a=[1,2,3];&gt;&gt; diag(a,-1)ans = 0 0 0 0 1 0 0 0 0 2 0 0 0 0 3 0 单元矩阵&emsp;&emsp;单元矩阵是对角阵的一种，只不过对角线的元素均为1。 12345&gt;&gt; eye(3)ans = 1 0 0 0 1 0 0 0 1 &emsp;&emsp;当然eye()函数也可以生成mxn的矩阵，当行数小于列数时，生成的是行满秩矩阵,当行数大于列数时，生成的是列满秩矩阵。 12345&gt;&gt; eye(3,2)ans = 1 0 0 1 0 0 矩阵的运算基础运算 &emsp;&emsp;矩阵的基础运算就是加减乘除四种，对于matlab来说还有点乘和点除，分别用 .* 和 ./ 表示。矩阵运算也有幂运算，但是也不难。需要注意的是矩阵的运算有很多时候不适用交换率，所以要注意下面的情况：$$(AB)^n \neq A^n B^n$$ 多项式计算&emsp;&emsp;矩阵也有多项式的形式：$f(A)=a_0A^n+a_1A^{n-1}+…+a_{n-1}A+a_nE$，其中E与A同阶。 12345&gt;&gt; A=[1,2;3,4];&gt;&gt; f=A^2+Af = 8 12 18 26 转置&emsp;&emsp;将一个矩阵的行换成同序数的列则可得到它的转置矩阵。 123456&gt;&gt; A=[1,2,3;4,5,6];&gt;&gt; A'ans = 1 4 2 5 3 6 在转置这里有两个新的概念： 对称阵：$A^T=A$ 反对称阵：$A^T=-A$]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
</search>
